<!DOCTYPE html>
<!-- è¿™ä¸ªæ–‡ä»¶ä¼šæ˜¯ä¸€ä¸ªå®Œæ•´çš„æµ‹è¯•ç•Œé¢æ–‡ä»¶ï¼Œè¯·ä¸è¦åˆ†ç¦»å®ƒçš„ js ä¸ css -->
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¿«é€Ÿæµ‹è¯•</title>
    <!-- Google Fonts & Material Icons -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #ff6b6b, #ffa726);
            color: white;
            padding: 24px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 8px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .content {
            padding: 24px;
        }

        .test-categories {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 24px;
        }

        .test-category {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .category-title {
            display: flex;
            align-items: center;
            font-size: 1.2rem;
            font-weight: 500;
            color: #333;
            margin-bottom: 16px;
        }

        .category-title .material-icons {
            margin-right: 8px;
            color: #667eea;
        }

        .test-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .test-btn {
            display: flex;
            align-items: center;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
            transition: all 0.3s ease;
            text-align: left;
        }

        .test-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .test-btn:active {
            transform: translateY(0);
        }

        .test-btn .material-icons {
            margin-right: 8px;
            font-size: 18px;
        }

        .test-btn.secondary {
            background: linear-gradient(135deg, #ffa726, #ff7043);
        }

        .test-btn.secondary:hover {
            box-shadow: 0 6px 20px rgba(255, 167, 38, 0.4);
        }

        .test-btn.danger {
            background: linear-gradient(135deg, #ef5350, #e91e63);
        }

        .test-btn.danger:hover {
            box-shadow: 0 6px 20px rgba(239, 83, 80, 0.4);
        }

        .results-section {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .results-title {
            display: flex;
            align-items: center;
            font-size: 1.2rem;
            font-weight: 500;
            color: #333;
            margin-bottom: 16px;
        }

        .results-title .material-icons {
            margin-right: 8px;
            color: #667eea;
        }

        .result {
            margin: 8px 0;
            padding: 12px 16px;
            border-radius: 8px;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            border-left: 4px solid;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .success {
            background: #e8f5e8;
            color: #2e7d32;
            border-left-color: #4caf50;
        }

        .error {
            background: #ffeaea;
            color: #c62828;
            border-left-color: #f44336;
        }

        .info {
            background: #e3f2fd;
            color: #1565c0;
            border-left-color: #2196f3;
        }

        .warning {
            background: #fff8e1;
            color: #ef6c00;
            border-left-color: #ff9800;
        }

        .clear-btn {
            background: linear-gradient(135deg, #78909c, #546e7a);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            margin-bottom: 16px;
            transition: all 0.3s ease;
        }

        .clear-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(120, 144, 156, 0.4);
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .test-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ§ª Labyrinthia AI æµ‹è¯•ä¸­å¿ƒ</h1>
            <div class="subtitle">å…¨é¢çš„æ¸¸æˆåŠŸèƒ½æµ‹è¯•ä¸è°ƒè¯•å·¥å…·</div>
        </div>

        <div class="content">
            <!-- æµ‹è¯•åˆ†ç±» -->
            <div class="test-categories">
                <!-- åŸºç¡€åŠŸèƒ½æµ‹è¯• -->
                <div class="test-category">
                    <div class="category-title">
                        <span class="material-icons">settings</span>
                        åŸºç¡€åŠŸèƒ½æµ‹è¯•
                    </div>
                    <div class="test-buttons">
                        <button class="test-btn" onclick="testBasicFunctionality()">
                            <span class="material-icons">check_circle</span>
                            åŸºç¡€åŠŸèƒ½æ£€æŸ¥
                        </button>
                        <button class="test-btn" onclick="testGameInitialization()">
                            <span class="material-icons">play_arrow</span>
                            æ¸¸æˆåˆå§‹åŒ–æµ‹è¯•
                        </button>
                        <button class="test-btn" onclick="testConfigLoading()">
                            <span class="material-icons">settings_applications</span>
                            é…ç½®åŠ è½½æµ‹è¯•
                        </button>
                    </div>
                </div>

                <!-- LLM APIæµ‹è¯• -->
                <div class="test-category">
                    <div class="category-title">
                        <span class="material-icons">cloud</span>
                        LLM API æµ‹è¯•
                    </div>
                    <div class="test-buttons">
                        <button class="test-btn" onclick="testGeminiConnection()">
                            <span class="material-icons">link</span>
                            Gemini API è¿æ¥
                        </button>
                        <button class="test-btn" onclick="testOpenRouterConnection()">
                            <span class="material-icons">router</span>
                            OpenRouter API è¿æ¥
                        </button>
                        <button class="test-btn" onclick="testContentGeneration()">
                            <span class="material-icons">auto_awesome</span>
                            å†…å®¹ç”Ÿæˆæµ‹è¯•
                        </button>
                    </div>
                </div>

                <!-- æ¸¸æˆæ ¸å¿ƒåŠŸèƒ½æµ‹è¯• -->
                <div class="test-category">
                    <div class="category-title">
                        <span class="material-icons">videogame_asset</span>
                        æ¸¸æˆæ ¸å¿ƒåŠŸèƒ½
                    </div>
                    <div class="test-buttons">
                        <button class="test-btn" onclick="testMapGeneration()">
                            <span class="material-icons">map</span>
                            åœ°å›¾ç”Ÿæˆæµ‹è¯•
                        </button>
                        <button class="test-btn" onclick="testCharacterSystem()">
                            <span class="material-icons">person</span>
                            è§’è‰²ç³»ç»Ÿæµ‹è¯•
                        </button>
                        <button class="test-btn" onclick="testQuestSystem()">
                            <span class="material-icons">assignment</span>
                            ä»»åŠ¡ç³»ç»Ÿæµ‹è¯•
                        </button>
                        <button class="test-btn" onclick="testItemSystem()">
                            <span class="material-icons">inventory</span>
                            ç‰©å“ç³»ç»Ÿæµ‹è¯•
                        </button>
                    </div>
                </div>

                <!-- æ•°æ®ç®¡ç†æµ‹è¯• -->
                <div class="test-category">
                    <div class="category-title">
                        <span class="material-icons">storage</span>
                        æ•°æ®ç®¡ç†æµ‹è¯•
                    </div>
                    <div class="test-buttons">
                        <button class="test-btn" onclick="testDataSaving()">
                            <span class="material-icons">save</span>
                            æ•°æ®ä¿å­˜æµ‹è¯•
                        </button>
                        <button class="test-btn" onclick="testDataLoading()">
                            <span class="material-icons">folder_open</span>
                            æ•°æ®åŠ è½½æµ‹è¯•
                        </button>
                        <button class="test-btn" onclick="testGameStateManagement()">
                            <span class="material-icons">manage_accounts</span>
                            æ¸¸æˆçŠ¶æ€ç®¡ç†
                        </button>
                    </div>
                </div>

                <!-- è°ƒè¯•åŠŸèƒ½ -->
                <div class="test-category">
                    <div class="category-title">
                        <span class="material-icons">bug_report</span>
                        è°ƒè¯•åŠŸèƒ½
                    </div>
                    <div class="test-buttons">
                        <button class="test-btn secondary" onclick="testDebugMethods()">
                            <span class="material-icons">build</span>
                            è°ƒè¯•æ–¹æ³•æµ‹è¯•
                        </button>
                        <button class="test-btn secondary" onclick="integrateDebugFeatures()">
                            <span class="material-icons">integration_instructions</span>
                            é›†æˆè°ƒè¯•åŠŸèƒ½
                        </button>
                        <button class="test-btn secondary" onclick="testDebugPanelToggle()">
                            <span class="material-icons">dashboard</span>
                            è°ƒè¯•é¢æ¿åˆ‡æ¢
                        </button>
                        <button class="test-btn secondary" onclick="testDebugModeCheck()">
                            <span class="material-icons">settings</span>
                            è°ƒè¯•æ¨¡å¼æ£€æŸ¥
                        </button>
                        <button class="test-btn secondary" onclick="triggerTestEvent()">
                            <span class="material-icons">event</span>
                            è§¦å‘æµ‹è¯•äº‹ä»¶
                        </button>
                        <button class="test-btn secondary" onclick="showGameState()">
                            <span class="material-icons">info</span>
                            æ˜¾ç¤ºæ¸¸æˆçŠ¶æ€
                        </button>
                    </div>
                </div>

                <!-- å‹åŠ›æµ‹è¯• -->
                <div class="test-category">
                    <div class="category-title">
                        <span class="material-icons">speed</span>
                        æ€§èƒ½ä¸å‹åŠ›æµ‹è¯•
                    </div>
                    <div class="test-buttons">
                        <button class="test-btn danger" onclick="runStressTest()">
                            <span class="material-icons">flash_on</span>
                            API å‹åŠ›æµ‹è¯•
                        </button>
                        <button class="test-btn danger" onclick="testMemoryUsage()">
                            <span class="material-icons">memory</span>
                            å†…å­˜ä½¿ç”¨æµ‹è¯•
                        </button>
                        <button class="test-btn danger" onclick="runFullSystemTest()">
                            <span class="material-icons">system_update_alt</span>
                            å®Œæ•´ç³»ç»Ÿæµ‹è¯•
                        </button>
                    </div>
                </div>
            </div>

            <!-- æµ‹è¯•ç»“æœæ˜¾ç¤ºåŒºåŸŸ -->
            <div class="results-section">
                <div class="results-title">
                    <span class="material-icons">assessment</span>
                    æµ‹è¯•ç»“æœ
                </div>
                <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
                    <button class="clear-btn" onclick="clearResults()">
                        <span class="material-icons" style="font-size: 14px; margin-right: 4px;">clear</span>
                        æ¸…ç©ºç»“æœ
                    </button>
                    <button class="clear-btn" onclick="generateTestReport()">
                        <span class="material-icons" style="font-size: 14px; margin-right: 4px;">assessment</span>
                        ç”ŸæˆæŠ¥å‘Š
                    </button>
                    <button class="clear-btn" onclick="exportTestResults()">
                        <span class="material-icons" style="font-size: 14px; margin-right: 4px;">download</span>
                        å¯¼å‡ºç»“æœ
                    </button>
                </div>
                <div id="results"></div>
            </div>
        </div>
    </div>

    <!-- åŠ è½½æ¸¸æˆè„šæœ¬ - æŒ‰ä¾èµ–é¡ºåºåŠ è½½ -->
    <script src="/static/GameCore.js"></script>
    <script src="/static/EventHandler.js"></script>
    <script src="/static/UIManager.js"></script>
    <script src="/static/SaveManager.js"></script>
    <script src="/static/OverlayManager.js"></script>
    <script src="/static/EffectsManager.js"></script>
    <script src="/static/MapInteraction.js"></script>
    <script src="/static/GameActions.js"></script>
    <script src="/static/EventChoiceManager.js"></script>
    <script src="/static/DebugManager.js"></script>

    <script>
        // å…¨å±€å˜é‡
        let testGame = null;
        let testResults = [];

        // å·¥å…·å‡½æ•°
        function log(message, type = 'info') {
            const results = document.getElementById('results');
            const div = document.createElement('div');
            div.className = `result ${type}`;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            results.appendChild(div);
            results.scrollTop = results.scrollHeight;

            // è®°å½•åˆ°æµ‹è¯•ç»“æœæ•°ç»„
            testResults.push({
                timestamp: new Date(),
                message: message,
                type: type
            });
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
            testResults = [];
            log('æµ‹è¯•ç»“æœå·²æ¸…ç©º', 'info');
        }

        function setButtonLoading(button, loading = true) {
            if (loading) {
                button.disabled = true;
                const originalText = button.innerHTML;
                button.setAttribute('data-original-text', originalText);
                button.innerHTML = '<span class="loading"></span>æµ‹è¯•ä¸­...';
            } else {
                button.disabled = false;
                const originalText = button.getAttribute('data-original-text');
                if (originalText) {
                    button.innerHTML = originalText;
                }
            }
        }

        async function withLoadingButton(button, asyncFunction) {
            setButtonLoading(button, true);
            try {
                await asyncFunction();
            } catch (error) {
                log(`æµ‹è¯•è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯: ${error.message}`, 'error');
            } finally {
                setButtonLoading(button, false);
            }
        }

        // ==================== åŸºç¡€åŠŸèƒ½æµ‹è¯• ====================

        async function testBasicFunctionality() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹åŸºç¡€åŠŸèƒ½æ£€æŸ¥...', 'info');

                // æ£€æŸ¥æ ¸å¿ƒç±»æ˜¯å¦å­˜åœ¨
                const coreClasses = [
                    'LabyrinthiaGame',
                    'addDebugMethodsToGame'
                ];

                let allClassesExist = true;
                coreClasses.forEach(className => {
                    if (typeof window[className] !== 'undefined') {
                        log(`âœ… ${className} å·²å®šä¹‰`, 'success');
                    } else {
                        log(`âŒ ${className} æœªå®šä¹‰`, 'error');
                        allClassesExist = false;
                    }
                });

                if (allClassesExist) {
                    log('ğŸ‰ æ‰€æœ‰æ ¸å¿ƒç±»æ£€æŸ¥é€šè¿‡ï¼', 'success');
                } else {
                    log('âš ï¸ éƒ¨åˆ†æ ¸å¿ƒç±»ç¼ºå¤±ï¼Œå¯èƒ½å½±å“æ¸¸æˆåŠŸèƒ½', 'warning');
                }
            });
        }

        async function testGameInitialization() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹æ¸¸æˆåˆå§‹åŒ–æµ‹è¯•...', 'info');

                try {
                    if (typeof LabyrinthiaGame === 'undefined') {
                        log('âŒ LabyrinthiaGame ç±»æœªå®šä¹‰', 'error');
                        return;
                    }

                    // åˆ›å»ºæµ‹è¯•æ¸¸æˆå®ä¾‹
                    testGame = new LabyrinthiaGame();
                    log('âœ… æ¸¸æˆå®ä¾‹åˆ›å»ºæˆåŠŸ', 'success');

                    // æ£€æŸ¥åŸºç¡€å±æ€§
                    const requiredProperties = [
                        'gameId', 'gameState', 'isLoading', 'messageLog',
                        'debugMode', 'config'
                    ];

                    let allPropertiesExist = true;
                    requiredProperties.forEach(prop => {
                        if (testGame.hasOwnProperty(prop)) {
                            log(`âœ… å±æ€§ ${prop} å­˜åœ¨`, 'success');
                        } else {
                            log(`âŒ å±æ€§ ${prop} ä¸å­˜åœ¨`, 'error');
                            allPropertiesExist = false;
                        }
                    });

                    // æ£€æŸ¥åŸºç¡€æ–¹æ³•
                    const requiredMethods = [
                        'init', 'loadConfig', 'initializeDebugMode',
                        'refreshGameState', 'updateUI'
                    ];

                    let allMethodsExist = true;
                    requiredMethods.forEach(method => {
                        if (typeof testGame[method] === 'function') {
                            log(`âœ… æ–¹æ³• ${method} å­˜åœ¨`, 'success');
                        } else {
                            log(`âŒ æ–¹æ³• ${method} ä¸å­˜åœ¨`, 'error');
                            allMethodsExist = false;
                        }
                    });

                    if (allPropertiesExist && allMethodsExist) {
                        log('ğŸ‰ æ¸¸æˆåˆå§‹åŒ–æµ‹è¯•é€šè¿‡ï¼', 'success');
                    } else {
                        log('âš ï¸ æ¸¸æˆåˆå§‹åŒ–å­˜åœ¨é—®é¢˜', 'warning');
                    }

                } catch (error) {
                    log(`âŒ æ¸¸æˆåˆå§‹åŒ–å¤±è´¥: ${error.message}`, 'error');
                }
            });
        }

        async function testConfigLoading() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹é…ç½®åŠ è½½æµ‹è¯•...', 'info');

                try {
                    const response = await fetch('/api/config');
                    if (response.ok) {
                        const config = await response.json();
                        log('âœ… é…ç½®æ–‡ä»¶åŠ è½½æˆåŠŸ', 'success');
                        log(`ğŸ“Š æ¸¸æˆåç§°: ${config.game?.game_name || 'æœªçŸ¥'}`, 'info');
                        log(`ğŸ“Š è°ƒè¯•æ¨¡å¼: ${config.game?.debug_mode ? 'å¯ç”¨' : 'ç¦ç”¨'}`, 'info');
                        log(`ğŸ“Š LLMæä¾›å•†: ${config.llm?.provider || 'æœªçŸ¥'}`, 'info');
                    } else {
                        log(`âŒ é…ç½®åŠ è½½å¤±è´¥: HTTP ${response.status}`, 'error');
                    }
                } catch (error) {
                    log(`âŒ é…ç½®åŠ è½½å¼‚å¸¸: ${error.message}`, 'error');
                }
            });
        }

        // ==================== LLM API æµ‹è¯• ====================

        async function testGeminiConnection() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹ Gemini API è¿æ¥æµ‹è¯•...', 'info');

                try {
                    const response = await fetch('/api/test/gemini', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ test_message: 'è¿™æ˜¯ä¸€ä¸ªè¿æ¥æµ‹è¯•' })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            log('âœ… Gemini API è¿æ¥æˆåŠŸ', 'success');
                            log(`ğŸ“ å“åº”: ${result.response || 'æ— å“åº”å†…å®¹'}`, 'info');
                        } else {
                            log(`âŒ Gemini API æµ‹è¯•å¤±è´¥: ${result.message}`, 'error');
                        }
                    } else {
                        log(`âŒ Gemini API è¯·æ±‚å¤±è´¥: HTTP ${response.status}`, 'error');
                    }
                } catch (error) {
                    log(`âŒ Gemini API è¿æ¥å¼‚å¸¸: ${error.message}`, 'error');
                }
            });
        }

        async function testOpenRouterConnection() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹ OpenRouter API è¿æ¥æµ‹è¯•...', 'info');

                try {
                    const response = await fetch('/api/test/openrouter', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ test_message: 'è¿™æ˜¯ä¸€ä¸ªè¿æ¥æµ‹è¯•' })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            log('âœ… OpenRouter API è¿æ¥æˆåŠŸ', 'success');
                            log(`ğŸ“ å“åº”: ${result.response || 'æ— å“åº”å†…å®¹'}`, 'info');
                        } else {
                            log(`âŒ OpenRouter API æµ‹è¯•å¤±è´¥: ${result.message}`, 'error');
                        }
                    } else {
                        log(`âŒ OpenRouter API è¯·æ±‚å¤±è´¥: HTTP ${response.status}`, 'error');
                    }
                } catch (error) {
                    log(`âŒ OpenRouter API è¿æ¥å¼‚å¸¸: ${error.message}`, 'error');
                }
            });
        }

        async function testContentGeneration() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹å†…å®¹ç”Ÿæˆæµ‹è¯•...', 'info');

                try {
                    const response = await fetch('/api/test/content-generation', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            test_type: 'simple_item',
                            player_level: 1
                        })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            log('âœ… å†…å®¹ç”Ÿæˆæµ‹è¯•æˆåŠŸ', 'success');
                            log(`ğŸ“¦ ç”Ÿæˆå†…å®¹ç±»å‹: ${result.content_type || 'æœªçŸ¥'}`, 'info');
                            if (result.generated_content) {
                                log(`ğŸ“ ç”Ÿæˆå†…å®¹: ${JSON.stringify(result.generated_content).substring(0, 100)}...`, 'info');
                            }
                        } else {
                            log(`âŒ å†…å®¹ç”Ÿæˆæµ‹è¯•å¤±è´¥: ${result.message}`, 'error');
                        }
                    } else {
                        log(`âŒ å†…å®¹ç”Ÿæˆè¯·æ±‚å¤±è´¥: HTTP ${response.status}`, 'error');
                    }
                } catch (error) {
                    log(`âŒ å†…å®¹ç”Ÿæˆæµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                }
            });
        }

        // ==================== æ¸¸æˆæ ¸å¿ƒåŠŸèƒ½æµ‹è¯• ====================

        async function testMapGeneration() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹åœ°å›¾ç”Ÿæˆæµ‹è¯•...', 'info');

                try {
                    const response = await fetch('/api/test/map-generation', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            width: 10,
                            height: 10,
                            depth: 1,
                            theme: 'æµ‹è¯•åœ°ä¸‹åŸ'
                        })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            log('âœ… åœ°å›¾ç”Ÿæˆæµ‹è¯•æˆåŠŸ', 'success');
                            log(`ğŸ—ºï¸ åœ°å›¾åç§°: ${result.map_name || 'æœªçŸ¥'}`, 'info');
                            log(`ğŸ“ åœ°å›¾å°ºå¯¸: ${result.map_size || 'æœªçŸ¥'}`, 'info');
                            log(`ğŸ  æˆ¿é—´æ•°é‡: ${result.room_count || 0}`, 'info');
                            log(`â­ ç‰¹æ®Šäº‹ä»¶: ${result.event_count || 0}`, 'info');
                        } else {
                            log(`âŒ åœ°å›¾ç”Ÿæˆæµ‹è¯•å¤±è´¥: ${result.message}`, 'error');
                        }
                    } else {
                        log(`âŒ åœ°å›¾ç”Ÿæˆè¯·æ±‚å¤±è´¥: HTTP ${response.status}`, 'error');
                    }
                } catch (error) {
                    log(`âŒ åœ°å›¾ç”Ÿæˆæµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                }
            });
        }

        async function testCharacterSystem() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹è§’è‰²ç³»ç»Ÿæµ‹è¯•...', 'info');

                try {
                    const response = await fetch('/api/test/character-system', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            character_name: 'æµ‹è¯•è§’è‰²',
                            character_class: 'warrior'
                        })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            log('âœ… è§’è‰²ç³»ç»Ÿæµ‹è¯•æˆåŠŸ', 'success');
                            log(`ğŸ‘¤ è§’è‰²åç§°: ${result.character_name || 'æœªçŸ¥'}`, 'info');
                            log(`âš”ï¸ è§’è‰²èŒä¸š: ${result.character_class || 'æœªçŸ¥'}`, 'info');
                            log(`ğŸ“Š å±æ€§ç»Ÿè®¡: ${result.stats_summary || 'æ— '}`, 'info');
                        } else {
                            log(`âŒ è§’è‰²ç³»ç»Ÿæµ‹è¯•å¤±è´¥: ${result.message}`, 'error');
                        }
                    } else {
                        log(`âŒ è§’è‰²ç³»ç»Ÿè¯·æ±‚å¤±è´¥: HTTP ${response.status}`, 'error');
                    }
                } catch (error) {
                    log(`âŒ è§’è‰²ç³»ç»Ÿæµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                }
            });
        }

        async function testQuestSystem() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹ä»»åŠ¡ç³»ç»Ÿæµ‹è¯•...', 'info');

                try {
                    const response = await fetch('/api/test/quest-system', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            player_level: 1,
                            quest_type: 'exploration'
                        })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            log('âœ… ä»»åŠ¡ç³»ç»Ÿæµ‹è¯•æˆåŠŸ', 'success');
                            log(`ğŸ“œ ä»»åŠ¡æ ‡é¢˜: ${result.quest_title || 'æœªçŸ¥'}`, 'info');
                            log(`ğŸ¯ ä»»åŠ¡ç±»å‹: ${result.quest_type || 'æœªçŸ¥'}`, 'info');
                            log(`ğŸ† ç›®æ ‡æ¥¼å±‚: ${result.target_floors || 'æœªçŸ¥'}`, 'info');
                            log(`â­ ä¸“å±äº‹ä»¶: ${result.special_events_count || 0} ä¸ª`, 'info');
                        } else {
                            log(`âŒ ä»»åŠ¡ç³»ç»Ÿæµ‹è¯•å¤±è´¥: ${result.message}`, 'error');
                        }
                    } else {
                        log(`âŒ ä»»åŠ¡ç³»ç»Ÿè¯·æ±‚å¤±è´¥: HTTP ${response.status}`, 'error');
                    }
                } catch (error) {
                    log(`âŒ ä»»åŠ¡ç³»ç»Ÿæµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                }
            });
        }

        async function testItemSystem() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹ç‰©å“ç³»ç»Ÿæµ‹è¯•...', 'info');

                try {
                    const response = await fetch('/api/test/item-system', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            item_type: 'weapon',
                            player_level: 1
                        })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            log('âœ… ç‰©å“ç³»ç»Ÿæµ‹è¯•æˆåŠŸ', 'success');
                            log(`ğŸ’ ç‰©å“åç§°: ${result.item_name || 'æœªçŸ¥'}`, 'info');
                            log(`ğŸ·ï¸ ç‰©å“ç±»å‹: ${result.item_type || 'æœªçŸ¥'}`, 'info');
                            log(`ğŸ’ ç‰©å“å“è´¨: ${result.item_rarity || 'æœªçŸ¥'}`, 'info');
                            log(`ğŸ“ ç‰©å“æè¿°: ${result.item_description?.substring(0, 50) || 'æ— '}...`, 'info');
                        } else {
                            log(`âŒ ç‰©å“ç³»ç»Ÿæµ‹è¯•å¤±è´¥: ${result.message}`, 'error');
                        }
                    } else {
                        log(`âŒ ç‰©å“ç³»ç»Ÿè¯·æ±‚å¤±è´¥: HTTP ${response.status}`, 'error');
                    }
                } catch (error) {
                    log(`âŒ ç‰©å“ç³»ç»Ÿæµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                }
            });
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–æµ‹è¯•ç¯å¢ƒï¼ˆä¸è‡ªåŠ¨è¿è¡Œæµ‹è¯•ï¼‰
        window.addEventListener('load', () => {
            initializeTestEnvironment();
        });

        function initializeTestEnvironment() {
            log('ğŸš€ æµ‹è¯•ç¯å¢ƒå·²å‡†å¤‡å°±ç»ªï¼Œé€‰æ‹©æµ‹è¯•åŠŸèƒ½å¼€å§‹æµ‹è¯•', 'info');
            log('ğŸ’¡ æç¤ºï¼šä¸åŒé¢œè‰²çš„æŒ‰é’®ä»£è¡¨ä¸åŒç±»å‹çš„æµ‹è¯•', 'info');
            log('âŒ¨ï¸ å¿«æ·é”®ï¼šCtrl+R=ç”ŸæˆæŠ¥å‘Š, Ctrl+E=å¯¼å‡ºç»“æœ, Ctrl+L=æ¸…ç©º', 'info');
            log('ğŸ–±ï¸ å³é”®ç‚¹å‡»ç»“æœåŒºåŸŸå¯æ˜¾ç¤ºæ›´å¤šé€‰é¡¹', 'info');

            // æ£€æŸ¥æ˜¯å¦æœ‰ç°æœ‰çš„æ¸¸æˆå®ä¾‹
            if (window.game) {
                log('ğŸ® æ£€æµ‹åˆ°ç°æœ‰æ¸¸æˆå®ä¾‹ï¼Œå¯ä»¥è¿›è¡Œé«˜çº§æµ‹è¯•', 'success');
                testGame = window.game;
            }

            // æ·»åŠ è°ƒè¯•åŠŸèƒ½é›†æˆ
            if (typeof addDebugMethodsToGame === 'function' && testGame) {
                try {
                    addDebugMethodsToGame(testGame);
                    log('ğŸ”§ è°ƒè¯•æ–¹æ³•å·²é›†æˆåˆ°æµ‹è¯•ç¯å¢ƒ', 'success');
                } catch (error) {
                    log(`âš ï¸ è°ƒè¯•æ–¹æ³•é›†æˆå¤±è´¥: ${error.message}`, 'warning');
                }
            }
        }

        // ==================== è°ƒè¯•åŠŸèƒ½é›†æˆ ====================

        async function integrateDebugFeatures() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹é›†æˆè°ƒè¯•åŠŸèƒ½...', 'info');

                try {
                    // æ£€æŸ¥è°ƒè¯•ç®¡ç†å™¨æ˜¯å¦å¯ç”¨
                    if (typeof DebugMethods !== 'undefined') {
                        log('âœ… DebugMethods å¯¹è±¡å¯ç”¨', 'success');

                        // åˆ—å‡ºå¯ç”¨çš„è°ƒè¯•æ–¹æ³•
                        const debugMethodNames = Object.getOwnPropertyNames(DebugMethods);
                        log(`ğŸ“‹ å¯ç”¨è°ƒè¯•æ–¹æ³•: ${debugMethodNames.length} ä¸ª`, 'info');

                        debugMethodNames.forEach(methodName => {
                            if (typeof DebugMethods[methodName] === 'function') {
                                log(`   ğŸ”§ ${methodName}`, 'info');
                            }
                        });

                        // å¦‚æœæœ‰æµ‹è¯•æ¸¸æˆå®ä¾‹ï¼Œæ·»åŠ è°ƒè¯•æ–¹æ³•
                        if (testGame) {
                            Object.assign(testGame, DebugMethods);
                            log('âœ… è°ƒè¯•æ–¹æ³•å·²æ·»åŠ åˆ°æµ‹è¯•æ¸¸æˆå®ä¾‹', 'success');
                        }

                    } else {
                        log('âŒ DebugMethods å¯¹è±¡ä¸å¯ç”¨', 'error');
                    }

                    // æ£€æŸ¥è°ƒè¯•é¢æ¿æ˜¯å¦å­˜åœ¨
                    const debugPanel = document.getElementById('debug-panel');
                    if (debugPanel) {
                        log('âœ… è°ƒè¯•é¢æ¿å…ƒç´ å­˜åœ¨', 'success');
                    } else {
                        log('âš ï¸ è°ƒè¯•é¢æ¿å…ƒç´ ä¸å­˜åœ¨', 'warning');
                    }

                    // æ£€æŸ¥è°ƒè¯•FABæŒ‰é’®
                    const debugFab = document.getElementById('debug-fab');
                    if (debugFab) {
                        log('âœ… è°ƒè¯•FABæŒ‰é’®å­˜åœ¨', 'success');
                    } else {
                        log('âš ï¸ è°ƒè¯•FABæŒ‰é’®ä¸å­˜åœ¨', 'warning');
                    }

                } catch (error) {
                    log(`âŒ è°ƒè¯•åŠŸèƒ½é›†æˆå¼‚å¸¸: ${error.message}`, 'error');
                }
            });
        }

        async function testDebugPanelToggle() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('æµ‹è¯•è°ƒè¯•é¢æ¿åˆ‡æ¢åŠŸèƒ½...', 'info');

                try {
                    if (testGame && typeof testGame.toggleDebugPanel === 'function') {
                        testGame.toggleDebugPanel();
                        log('âœ… è°ƒè¯•é¢æ¿åˆ‡æ¢æˆåŠŸ', 'success');

                        // æ£€æŸ¥é¢æ¿çŠ¶æ€
                        const debugPanel = document.getElementById('debug-panel');
                        if (debugPanel) {
                            const isVisible = debugPanel.style.display !== 'none';
                            log(`ğŸ“Š è°ƒè¯•é¢æ¿çŠ¶æ€: ${isVisible ? 'æ˜¾ç¤º' : 'éšè—'}`, 'info');
                        }
                    } else {
                        log('âŒ è°ƒè¯•é¢æ¿åˆ‡æ¢åŠŸèƒ½ä¸å¯ç”¨', 'error');
                    }
                } catch (error) {
                    log(`âŒ è°ƒè¯•é¢æ¿åˆ‡æ¢æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                }
            });
        }

        async function testDebugModeCheck() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('æ£€æŸ¥è°ƒè¯•æ¨¡å¼çŠ¶æ€...', 'info');

                try {
                    // æ£€æŸ¥é…ç½®ä¸­çš„è°ƒè¯•æ¨¡å¼
                    const response = await fetch('/api/config');
                    if (response.ok) {
                        const config = await response.json();
                        const debugMode = config.config?.game?.debug_mode;
                        const showLLMDebug = config.config?.game?.show_llm_debug;

                        log(`ğŸ”§ è°ƒè¯•æ¨¡å¼: ${debugMode ? 'å¯ç”¨' : 'ç¦ç”¨'}`, debugMode ? 'success' : 'warning');
                        log(`ğŸ¤– LLMè°ƒè¯•: ${showLLMDebug ? 'å¯ç”¨' : 'ç¦ç”¨'}`, showLLMDebug ? 'success' : 'info');

                        if (testGame) {
                            log(`ğŸ® æ¸¸æˆå®ä¾‹è°ƒè¯•æ¨¡å¼: ${testGame.debugMode ? 'å¯ç”¨' : 'ç¦ç”¨'}`, testGame.debugMode ? 'success' : 'info');
                        }
                    }

                    // æ£€æŸ¥è°ƒè¯•çŠ¶æ€å‡½æ•°
                    if (typeof window.checkDebugStatus === 'function') {
                        window.checkDebugStatus();
                        log('âœ… è°ƒè¯•çŠ¶æ€æ£€æŸ¥å‡½æ•°å·²æ‰§è¡Œ', 'success');
                    } else {
                        log('âš ï¸ è°ƒè¯•çŠ¶æ€æ£€æŸ¥å‡½æ•°ä¸å­˜åœ¨', 'warning');
                    }

                } catch (error) {
                    log(`âŒ è°ƒè¯•æ¨¡å¼æ£€æŸ¥å¤±è´¥: ${error.message}`, 'error');
                }
            });
        }

        // ==================== æ•°æ®ç®¡ç†æµ‹è¯• ====================

        async function testDataSaving() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹æ•°æ®ä¿å­˜æµ‹è¯•...', 'info');

                try {
                    const testData = {
                        test_save: true,
                        timestamp: new Date().toISOString(),
                        player_name: 'æµ‹è¯•ç©å®¶',
                        level: 1
                    };

                    const response = await fetch('/api/test/data-saving', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(testData)
                    });

                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            log('âœ… æ•°æ®ä¿å­˜æµ‹è¯•æˆåŠŸ', 'success');
                            log(`ğŸ’¾ ä¿å­˜æ–‡ä»¶: ${result.save_file || 'æœªçŸ¥'}`, 'info');
                            log(`ğŸ“Š æ•°æ®å¤§å°: ${result.data_size || 'æœªçŸ¥'}`, 'info');
                        } else {
                            log(`âŒ æ•°æ®ä¿å­˜æµ‹è¯•å¤±è´¥: ${result.message}`, 'error');
                        }
                    } else {
                        log(`âŒ æ•°æ®ä¿å­˜è¯·æ±‚å¤±è´¥: HTTP ${response.status}`, 'error');
                    }
                } catch (error) {
                    log(`âŒ æ•°æ®ä¿å­˜æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                }
            });
        }

        async function testDataLoading() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹æ•°æ®åŠ è½½æµ‹è¯•...', 'info');

                try {
                    const response = await fetch('/api/test/data-loading', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ test_load: true })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            log('âœ… æ•°æ®åŠ è½½æµ‹è¯•æˆåŠŸ', 'success');
                            log(`ğŸ“‚ å¯ç”¨å­˜æ¡£: ${result.save_count || 0} ä¸ª`, 'info');
                            log(`ğŸ“Š æœ€æ–°å­˜æ¡£: ${result.latest_save || 'æ— '}`, 'info');
                        } else {
                            log(`âŒ æ•°æ®åŠ è½½æµ‹è¯•å¤±è´¥: ${result.message}`, 'error');
                        }
                    } else {
                        log(`âŒ æ•°æ®åŠ è½½è¯·æ±‚å¤±è´¥: HTTP ${response.status}`, 'error');
                    }
                } catch (error) {
                    log(`âŒ æ•°æ®åŠ è½½æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                }
            });
        }

        async function testGameStateManagement() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹æ¸¸æˆçŠ¶æ€ç®¡ç†æµ‹è¯•...', 'info');

                try {
                    const response = await fetch('/api/test/gamestate-management', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ test_gamestate: true })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            log('âœ… æ¸¸æˆçŠ¶æ€ç®¡ç†æµ‹è¯•æˆåŠŸ', 'success');
                            log(`ğŸ® æ´»è·ƒæ¸¸æˆ: ${result.active_games || 0} ä¸ª`, 'info');
                            log(`ğŸ’¾ çŠ¶æ€åŒæ­¥: ${result.sync_status || 'æœªçŸ¥'}`, 'info');
                        } else {
                            log(`âŒ æ¸¸æˆçŠ¶æ€ç®¡ç†æµ‹è¯•å¤±è´¥: ${result.message}`, 'error');
                        }
                    } else {
                        log(`âŒ æ¸¸æˆçŠ¶æ€ç®¡ç†è¯·æ±‚å¤±è´¥: HTTP ${response.status}`, 'error');
                    }
                } catch (error) {
                    log(`âŒ æ¸¸æˆçŠ¶æ€ç®¡ç†æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                }
            });
        }

        // ==================== è°ƒè¯•åŠŸèƒ½æµ‹è¯• ====================

        async function testDebugMethods() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹è°ƒè¯•æ–¹æ³•æµ‹è¯•...', 'info');

                try {
                    // æ£€æŸ¥è°ƒè¯•æ–¹æ³•æ˜¯å¦å­˜åœ¨
                    if (typeof addDebugMethodsToGame === 'function') {
                        log('âœ… addDebugMethodsToGame å‡½æ•°å­˜åœ¨', 'success');

                        if (testGame) {
                            // æ·»åŠ è°ƒè¯•æ–¹æ³•åˆ°æµ‹è¯•æ¸¸æˆå®ä¾‹
                            addDebugMethodsToGame(testGame);

                            // æ£€æŸ¥è°ƒè¯•æ–¹æ³•
                            const debugMethods = [
                                'debugTriggerRandomEvent',
                                'debugCompleteCurrentQuest',
                                'debugGenerateTestItem',
                                'debugTeleportToFloor',
                                'debugGenerateEnemy',
                                'debugClearEnemies'
                            ];

                            let methodCount = 0;
                            debugMethods.forEach(method => {
                                if (typeof testGame[method] === 'function') {
                                    log(`âœ… ${method} æ–¹æ³•å¯ç”¨`, 'success');
                                    methodCount++;
                                } else {
                                    log(`âŒ ${method} æ–¹æ³•ä¸å­˜åœ¨`, 'error');
                                }
                            });

                            log(`ğŸ“Š è°ƒè¯•æ–¹æ³•ç»Ÿè®¡: ${methodCount}/${debugMethods.length} å¯ç”¨`, 'info');

                        } else {
                            log('âš ï¸ éœ€è¦å…ˆè¿è¡Œæ¸¸æˆåˆå§‹åŒ–æµ‹è¯•', 'warning');
                        }
                    } else {
                        log('âŒ addDebugMethodsToGame å‡½æ•°ä¸å­˜åœ¨', 'error');
                    }
                } catch (error) {
                    log(`âŒ è°ƒè¯•æ–¹æ³•æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                }
            });
        }

        async function triggerTestEvent() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹è§¦å‘æµ‹è¯•äº‹ä»¶...', 'info');

                try {
                    const response = await fetch('/api/test/trigger-event', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            event_type: 'test',
                            test_data: 'è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•äº‹ä»¶'
                        })
                    });

                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            log('âœ… æµ‹è¯•äº‹ä»¶è§¦å‘æˆåŠŸ', 'success');
                            log(`ğŸ­ äº‹ä»¶ç±»å‹: ${result.event_type || 'æœªçŸ¥'}`, 'info');
                            log(`ğŸ“ äº‹ä»¶ç»“æœ: ${result.event_result || 'æ— '}`, 'info');
                        } else {
                            log(`âŒ æµ‹è¯•äº‹ä»¶è§¦å‘å¤±è´¥: ${result.message}`, 'error');
                        }
                    } else {
                        log(`âŒ æµ‹è¯•äº‹ä»¶è¯·æ±‚å¤±è´¥: HTTP ${response.status}`, 'error');
                    }
                } catch (error) {
                    log(`âŒ æµ‹è¯•äº‹ä»¶è§¦å‘å¼‚å¸¸: ${error.message}`, 'error');
                }
            });
        }

        async function showGameState() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹æ˜¾ç¤ºæ¸¸æˆçŠ¶æ€...', 'info');

                try {
                    if (testGame && testGame.gameState) {
                        const gameState = testGame.gameState;
                        log('âœ… æ¸¸æˆçŠ¶æ€è·å–æˆåŠŸ', 'success');
                        log(`ğŸ‘¤ ç©å®¶: ${gameState.player?.name || 'æœªçŸ¥'}`, 'info');
                        log(`ğŸ“ ä½ç½®: ${gameState.player?.position || 'æœªçŸ¥'}`, 'info');
                        log(`ğŸ—ºï¸ å½“å‰åœ°å›¾: ${gameState.current_map?.name || 'æœªçŸ¥'}`, 'info');
                        log(`ğŸ“œ æ´»è·ƒä»»åŠ¡: ${gameState.quests?.find(q => q.is_active)?.title || 'æ— '}`, 'info');
                    } else {
                        log('âš ï¸ æ¸¸æˆçŠ¶æ€ä¸å¯ç”¨ï¼Œè¯·å…ˆå¼€å§‹æ¸¸æˆ', 'warning');

                        // å°è¯•ä»æœåŠ¡å™¨è·å–æ¸¸æˆçŠ¶æ€
                        const response = await fetch('/api/test/game-state');
                        if (response.ok) {
                            const result = await response.json();
                            if (result.success) {
                                log('âœ… ä»æœåŠ¡å™¨è·å–æ¸¸æˆçŠ¶æ€æˆåŠŸ', 'success');
                                log(`ğŸ® æ´»è·ƒæ¸¸æˆæ•°: ${result.active_games || 0}`, 'info');
                            }
                        }
                    }
                } catch (error) {
                    log(`âŒ æ˜¾ç¤ºæ¸¸æˆçŠ¶æ€å¼‚å¸¸: ${error.message}`, 'error');
                }
            });
        }

        // ==================== æ€§èƒ½ä¸å‹åŠ›æµ‹è¯• ====================

        async function runStressTest() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹ API å‹åŠ›æµ‹è¯•...', 'warning');
                log('âš ï¸ æ³¨æ„ï¼šæ­¤æµ‹è¯•å°†å‘é€å¤šä¸ªå¹¶å‘è¯·æ±‚', 'warning');

                const testCount = 5;
                const promises = [];

                try {
                    // åˆ›å»ºå¤šä¸ªå¹¶å‘è¯·æ±‚
                    for (let i = 0; i < testCount; i++) {
                        const promise = fetch('/api/test/stress-test', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                test_id: i + 1,
                                timestamp: new Date().toISOString()
                            })
                        });
                        promises.push(promise);
                    }

                    log(`ğŸš€ å‘é€ ${testCount} ä¸ªå¹¶å‘è¯·æ±‚...`, 'info');
                    const startTime = Date.now();

                    const responses = await Promise.all(promises);
                    const endTime = Date.now();
                    const totalTime = endTime - startTime;

                    let successCount = 0;
                    let errorCount = 0;

                    for (let i = 0; i < responses.length; i++) {
                        const response = responses[i];
                        if (response.ok) {
                            successCount++;
                            log(`âœ… è¯·æ±‚ ${i + 1} æˆåŠŸ (${response.status})`, 'success');
                        } else {
                            errorCount++;
                            log(`âŒ è¯·æ±‚ ${i + 1} å¤±è´¥ (${response.status})`, 'error');
                        }
                    }

                    log(`ğŸ“Š å‹åŠ›æµ‹è¯•å®Œæˆ`, 'info');
                    log(`â±ï¸ æ€»è€—æ—¶: ${totalTime}ms`, 'info');
                    log(`âœ… æˆåŠŸ: ${successCount}/${testCount}`, 'success');
                    log(`âŒ å¤±è´¥: ${errorCount}/${testCount}`, errorCount > 0 ? 'error' : 'info');
                    log(`ğŸ“ˆ å¹³å‡å“åº”æ—¶é—´: ${(totalTime / testCount).toFixed(2)}ms`, 'info');

                } catch (error) {
                    log(`âŒ å‹åŠ›æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                }
            });
        }

        async function testMemoryUsage() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹å†…å­˜ä½¿ç”¨æµ‹è¯•...', 'info');

                try {
                    // æ£€æŸ¥æµè§ˆå™¨å†…å­˜APIæ”¯æŒ
                    if ('memory' in performance) {
                        const memory = performance.memory;
                        log('âœ… æµè§ˆå™¨å†…å­˜ä¿¡æ¯å¯ç”¨', 'success');
                        log(`ğŸ’¾ å·²ç”¨å†…å­˜: ${(memory.usedJSHeapSize / 1024 / 1024).toFixed(2)} MB`, 'info');
                        log(`ğŸ“Š æ€»å†…å­˜: ${(memory.totalJSHeapSize / 1024 / 1024).toFixed(2)} MB`, 'info');
                        log(`ğŸ”’ å†…å­˜é™åˆ¶: ${(memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2)} MB`, 'info');

                        // è®¡ç®—å†…å­˜ä½¿ç”¨ç‡
                        const usagePercent = ((memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100).toFixed(2);
                        log(`ğŸ“ˆ å†…å­˜ä½¿ç”¨ç‡: ${usagePercent}%`, usagePercent > 80 ? 'warning' : 'info');
                    } else {
                        log('âš ï¸ æµè§ˆå™¨ä¸æ”¯æŒå†…å­˜API', 'warning');
                    }

                    // æµ‹è¯•æœåŠ¡å™¨å†…å­˜ä½¿ç”¨
                    const response = await fetch('/api/test/memory-usage');
                    if (response.ok) {
                        const result = await response.json();
                        if (result.success) {
                            log('âœ… æœåŠ¡å™¨å†…å­˜ä¿¡æ¯è·å–æˆåŠŸ', 'success');
                            log(`ğŸ–¥ï¸ æœåŠ¡å™¨å†…å­˜ä½¿ç”¨: ${result.memory_usage || 'æœªçŸ¥'}`, 'info');
                            log(`ğŸ’½ ç£ç›˜ä½¿ç”¨: ${result.disk_usage || 'æœªçŸ¥'}`, 'info');
                        }
                    }

                    // æµ‹è¯•å¯¹è±¡åˆ›å»ºå’Œåƒåœ¾å›æ”¶
                    log('ğŸ§ª æµ‹è¯•å¯¹è±¡åˆ›å»ºå’Œå†…å­˜å›æ”¶...', 'info');
                    const testObjects = [];
                    for (let i = 0; i < 1000; i++) {
                        testObjects.push({
                            id: i,
                            data: new Array(100).fill(Math.random()),
                            timestamp: new Date()
                        });
                    }

                    log(`ğŸ“¦ åˆ›å»ºäº† ${testObjects.length} ä¸ªæµ‹è¯•å¯¹è±¡`, 'info');

                    // æ¸…ç†æµ‹è¯•å¯¹è±¡
                    testObjects.length = 0;

                    // å»ºè®®åƒåœ¾å›æ”¶ï¼ˆå¦‚æœæ”¯æŒï¼‰
                    if (window.gc) {
                        window.gc();
                        log('ğŸ—‘ï¸ æ‰‹åŠ¨è§¦å‘åƒåœ¾å›æ”¶', 'info');
                    } else {
                        log('â„¹ï¸ æµè§ˆå™¨ä¸æ”¯æŒæ‰‹åŠ¨åƒåœ¾å›æ”¶', 'info');
                    }

                } catch (error) {
                    log(`âŒ å†…å­˜ä½¿ç”¨æµ‹è¯•å¼‚å¸¸: ${error.message}`, 'error');
                }
            });
        }

        async function runFullSystemTest() {
            const button = event.target;
            await withLoadingButton(button, async () => {
                log('å¼€å§‹å®Œæ•´ç³»ç»Ÿæµ‹è¯•...', 'warning');
                log('ğŸ”„ è¿™å°†è¿è¡Œæ‰€æœ‰ä¸»è¦æµ‹è¯•åŠŸèƒ½', 'info');

                const testFunctions = [
                    { name: 'åŸºç¡€åŠŸèƒ½æ£€æŸ¥', func: () => testBasicFunctionality() },
                    { name: 'é…ç½®åŠ è½½æµ‹è¯•', func: () => testConfigLoading() },
                    { name: 'Gemini APIæµ‹è¯•', func: () => testGeminiConnection() },
                    { name: 'åœ°å›¾ç”Ÿæˆæµ‹è¯•', func: () => testMapGeneration() },
                    { name: 'è§’è‰²ç³»ç»Ÿæµ‹è¯•', func: () => testCharacterSystem() },
                    { name: 'ä»»åŠ¡ç³»ç»Ÿæµ‹è¯•', func: () => testQuestSystem() },
                    { name: 'ç‰©å“ç³»ç»Ÿæµ‹è¯•', func: () => testItemSystem() },
                    { name: 'æ•°æ®ä¿å­˜æµ‹è¯•', func: () => testDataSaving() },
                    { name: 'æ•°æ®åŠ è½½æµ‹è¯•', func: () => testDataLoading() }
                ];

                let passedTests = 0;
                let failedTests = 0;
                const startTime = Date.now();

                for (let i = 0; i < testFunctions.length; i++) {
                    const test = testFunctions[i];
                    log(`ğŸ”„ [${i + 1}/${testFunctions.length}] è¿è¡Œ: ${test.name}`, 'info');

                    try {
                        // æ¨¡æ‹ŸæŒ‰é’®ç‚¹å‡»äº‹ä»¶
                        const mockEvent = { target: button };
                        window.event = mockEvent;

                        await test.func();
                        passedTests++;
                        log(`âœ… ${test.name} å®Œæˆ`, 'success');
                    } catch (error) {
                        failedTests++;
                        log(`âŒ ${test.name} å¤±è´¥: ${error.message}`, 'error');
                    }

                    // æ·»åŠ çŸ­æš‚å»¶è¿Ÿé¿å…è¯·æ±‚è¿‡äºé¢‘ç¹
                    await new Promise(resolve => setTimeout(resolve, 500));
                }

                const endTime = Date.now();
                const totalTime = endTime - startTime;

                log('ğŸ å®Œæ•´ç³»ç»Ÿæµ‹è¯•å®Œæˆ', 'info');
                log(`â±ï¸ æ€»è€—æ—¶: ${(totalTime / 1000).toFixed(2)} ç§’`, 'info');
                log(`âœ… é€šè¿‡æµ‹è¯•: ${passedTests}/${testFunctions.length}`, 'success');
                log(`âŒ å¤±è´¥æµ‹è¯•: ${failedTests}/${testFunctions.length}`, failedTests > 0 ? 'error' : 'info');

                const successRate = ((passedTests / testFunctions.length) * 100).toFixed(2);
                log(`ğŸ“Š æˆåŠŸç‡: ${successRate}%`, successRate >= 80 ? 'success' : 'warning');

                if (successRate >= 90) {
                    log('ğŸ‰ ç³»ç»ŸçŠ¶æ€ä¼˜ç§€ï¼', 'success');
                } else if (successRate >= 70) {
                    log('âš ï¸ ç³»ç»ŸçŠ¶æ€è‰¯å¥½ï¼Œä½†æœ‰æ”¹è¿›ç©ºé—´', 'warning');
                } else {
                    log('ğŸš¨ ç³»ç»Ÿå­˜åœ¨è¾ƒå¤šé—®é¢˜ï¼Œéœ€è¦æ£€æŸ¥', 'error');
                }
            });
        }

        // ==================== é¢å¤–çš„å·¥å…·å‡½æ•° ====================

        function exportTestResults() {
            if (testResults.length === 0) {
                log('æ²¡æœ‰æµ‹è¯•ç»“æœå¯å¯¼å‡º', 'warning');
                return;
            }

            const exportData = {
                export_time: new Date().toISOString(),
                test_session: `test_${Date.now()}`,
                total_tests: testResults.length,
                results: testResults
            };

            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});

            const link = document.createElement('a');
            link.href = URL.createObjectURL(dataBlob);
            link.download = `labyrinthia_test_results_${new Date().toISOString().split('T')[0]}.json`;
            link.click();

            log('âœ… æµ‹è¯•ç»“æœå·²å¯¼å‡º', 'success');
        }

        function generateTestReport() {
            if (testResults.length === 0) {
                log('æ²¡æœ‰æµ‹è¯•ç»“æœå¯ç”ŸæˆæŠ¥å‘Š', 'warning');
                return;
            }

            const successCount = testResults.filter(r => r.type === 'success').length;
            const errorCount = testResults.filter(r => r.type === 'error').length;
            const warningCount = testResults.filter(r => r.type === 'warning').length;
            const infoCount = testResults.filter(r => r.type === 'info').length;

            log('ğŸ“Š æµ‹è¯•æŠ¥å‘Šç”Ÿæˆ', 'info');
            log(`ğŸ“ˆ æ€»æµ‹è¯•æ•°: ${testResults.length}`, 'info');
            log(`âœ… æˆåŠŸ: ${successCount}`, 'success');
            log(`âŒ é”™è¯¯: ${errorCount}`, errorCount > 0 ? 'error' : 'info');
            log(`âš ï¸ è­¦å‘Š: ${warningCount}`, warningCount > 0 ? 'warning' : 'info');
            log(`â„¹ï¸ ä¿¡æ¯: ${infoCount}`, 'info');

            const successRate = ((successCount / (successCount + errorCount)) * 100).toFixed(2);
            log(`ğŸ“Š æˆåŠŸç‡: ${successRate}%`, successRate >= 80 ? 'success' : 'warning');

            // æ˜¾ç¤ºæœ€è¿‘çš„é”™è¯¯
            const recentErrors = testResults.filter(r => r.type === 'error').slice(-3);
            if (recentErrors.length > 0) {
                log('ğŸ” æœ€è¿‘çš„é”™è¯¯:', 'warning');
                recentErrors.forEach(error => {
                    log(`   ${error.message}`, 'error');
                });
            }
        }

        // æ·»åŠ é”®ç›˜å¿«æ·é”®æ”¯æŒ
        document.addEventListener('keydown', function(event) {
            // Ctrl+R: ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š
            if (event.ctrlKey && event.key === 'r') {
                event.preventDefault();
                generateTestReport();
            }
            // Ctrl+E: å¯¼å‡ºæµ‹è¯•ç»“æœ
            else if (event.ctrlKey && event.key === 'e') {
                event.preventDefault();
                exportTestResults();
            }
            // Ctrl+L: æ¸…ç©ºç»“æœ
            else if (event.ctrlKey && event.key === 'l') {
                event.preventDefault();
                clearResults();
            }
        });

        // æ·»åŠ å³é”®èœå•åŠŸèƒ½
        document.getElementById('results').addEventListener('contextmenu', function(event) {
            event.preventDefault();

            // åˆ›å»ºç®€å•çš„ä¸Šä¸‹æ–‡èœå•
            const menu = document.createElement('div');
            menu.style.cssText = `
                position: fixed;
                top: ${event.clientY}px;
                left: ${event.clientX}px;
                background: white;
                border: 1px solid #ccc;
                border-radius: 4px;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                z-index: 1000;
                padding: 8px 0;
                min-width: 150px;
            `;

            const menuItems = [
                { text: 'ç”Ÿæˆæµ‹è¯•æŠ¥å‘Š', action: generateTestReport },
                { text: 'å¯¼å‡ºæµ‹è¯•ç»“æœ', action: exportTestResults },
                { text: 'æ¸…ç©ºç»“æœ', action: clearResults }
            ];

            menuItems.forEach(item => {
                const menuItem = document.createElement('div');
                menuItem.textContent = item.text;
                menuItem.style.cssText = `
                    padding: 8px 16px;
                    cursor: pointer;
                    font-size: 14px;
                `;
                menuItem.addEventListener('mouseenter', () => {
                    menuItem.style.backgroundColor = '#f0f0f0';
                });
                menuItem.addEventListener('mouseleave', () => {
                    menuItem.style.backgroundColor = 'transparent';
                });
                menuItem.addEventListener('click', () => {
                    item.action();
                    document.body.removeChild(menu);
                });
                menu.appendChild(menuItem);
            });

            document.body.appendChild(menu);

            // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­èœå•
            setTimeout(() => {
                document.addEventListener('click', function closeMenu() {
                    if (document.body.contains(menu)) {
                        document.body.removeChild(menu);
                    }
                    document.removeEventListener('click', closeMenu);
                }, 100);
            });
        });
    </script>
</body>
</html>
