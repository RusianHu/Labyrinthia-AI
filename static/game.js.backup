// Labyrinthia AI - æ¸¸æˆå‰ç«¯è„šæœ¬

class LabyrinthiaGame {
    constructor() {
        this.gameId = null;
        this.gameState = null;
        this.isLoading = false;
        this.messageLog = [];
        this.debugMode = false;
        this.lastLLMRequest = null;
        this.lastLLMResponse = null;
        this.hoveredTile = null;
        this.highlightedTiles = [];
        this.currentProgressInterval = null;
        this.config = null;

        this.init();
        this.initializeDebugMode();
        this.loadConfig();
    }
    
    init() {
        this.setupEventListeners();
        this.loadGameList();
    }

    initializeDebugMode() {
        // æ£€æŸ¥é…ç½®ä¸­æ˜¯å¦å¯ç”¨è°ƒè¯•æ¨¡å¼
        this.checkDebugMode();

        // è®¾ç½®FABæŒ‰é’®äº‹ä»¶
        const debugFab = document.getElementById('debug-fab');
        if (debugFab) {
            debugFab.addEventListener('click', () => {
                this.toggleDebugPanel();
            });
        }
    }

    async checkDebugMode() {
        try {
            const response = await fetch('/api/config');
            const result = await response.json();
            const config = result.config || result; // å…¼å®¹æ–°æ—§æ ¼å¼
            this.debugMode = config.game?.show_llm_debug || false;

            this.updateDebugFabVisibility();
        } catch (error) {
            console.error('Failed to check debug mode:', error);
        }
    }

    toggleDebugPanel() {
        const debugPanel = document.getElementById('debug-panel');
        if (debugPanel) {
            debugPanel.classList.toggle('show');
            this.updateDebugInfo();
        }
    }

    updateDebugInfo() {
        if (!this.debugMode) return;

        // æ›´æ–°LLMè¯·æ±‚ä¿¡æ¯
        const requestElement = document.getElementById('debug-request');
        if (requestElement && this.lastLLMRequest) {
            requestElement.textContent = JSON.stringify(this.lastLLMRequest, null, 2);
        }

        // æ›´æ–°LLMå“åº”ä¿¡æ¯
        const responseElement = document.getElementById('debug-response');
        if (responseElement && this.lastLLMResponse) {
            responseElement.textContent = JSON.stringify(this.lastLLMResponse, null, 2);
        }

        // æ›´æ–°æ¸¸æˆçŠ¶æ€ä¿¡æ¯
        const gameStateElement = document.getElementById('debug-gamestate');
        if (gameStateElement && this.gameState) {
            const debugGameState = {
                player_position: this.gameState.player.position,
                player_hp: this.gameState.player.stats.hp,
                player_level: this.gameState.player.stats.level,
                map_name: this.gameState.current_map.name,
                turn_count: this.gameState.turn_count,
                monsters_count: this.gameState.monsters.length
            };
            gameStateElement.textContent = JSON.stringify(debugGameState, null, 2);
        }
    }
    
    setupEventListeners() {
        // æ–¹å‘æ§åˆ¶æŒ‰é’®
        document.querySelectorAll('.dir-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                const direction = e.target.dataset.direction;
                if (direction) {
                    this.movePlayer(direction);
                }
            });
        });
        
        // é”®ç›˜æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            if (this.gameId) {
                this.handleKeyPress(e);
            }
        });
        
        // å…¶ä»–æ§åˆ¶æŒ‰é’®
        document.getElementById('btn-rest')?.addEventListener('click', () => {
            this.performAction('rest');
        });
        
        document.getElementById('btn-save')?.addEventListener('click', () => {
            this.saveGame();
        });
        
        document.getElementById('btn-new-game')?.addEventListener('click', () => {
            this.showNewGameModal();
        });
        
        // æ¨¡æ€æ¡†æ§åˆ¶
        document.querySelectorAll('.close').forEach(closeBtn => {
            closeBtn.addEventListener('click', (e) => {
                e.target.closest('.modal').style.display = 'none';
            });
        });
        
        // ç‚¹å‡»æ¨¡æ€æ¡†å¤–éƒ¨å…³é—­
        window.addEventListener('click', (e) => {
            if (e.target.classList.contains('modal')) {
                e.target.style.display = 'none';
            }
        });
    }
    
    handleKeyPress(e) {
        const keyMap = {
            'ArrowUp': 'north',
            'ArrowDown': 'south',
            'ArrowLeft': 'west',
            'ArrowRight': 'east',
            'w': 'north',
            's': 'south',
            'a': 'west',
            'd': 'east',
            'q': 'northwest',
            'e': 'northeast',
            'z': 'southwest',
            'c': 'southeast',
            'r': 'rest',
            ' ': 'rest'
        };
        
        const action = keyMap[e.key.toLowerCase()];
        if (action) {
            e.preventDefault();
            if (action === 'rest') {
                this.performAction('rest');
            } else {
                this.movePlayer(action);
            }
        }
    }
    
    async movePlayer(direction) {
        if (this.isLoading) return;
        
        await this.performAction('move', { direction });
    }
    
    async performAction(action, parameters = {}) {
        if (this.isLoading || !this.gameId) return;

        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ˜¾ç¤ºç‰¹å®šçš„LLMé®ç½©ï¼ˆç‰¹æ®Šåœ°å½¢æˆ–äº‹ä»¶è§¦å‘æ—¶ï¼‰
        const needsSpecificLLMOverlay = this.shouldShowLLMOverlay(action, parameters);

        // å¦‚æœéœ€è¦ç‰¹å®šçš„LLMé®ç½©ï¼Œå…ˆæ˜¾ç¤ºå®ƒï¼Œç„¶åå†è®¾ç½®loading
        if (needsSpecificLLMOverlay) {
            this.showLLMOverlay(action);
            this.isLoading = true;
            // ç¦ç”¨æ§åˆ¶æŒ‰é’®ä½†ä¸æ˜¾ç¤ºé€šç”¨çš„loading indicator
            const controlButtons = document.querySelectorAll('.control-btn, .dir-btn');
            controlButtons.forEach(btn => {
                btn.disabled = true;
            });
        } else {
            // æ™®é€šæƒ…å†µï¼Œä½¿ç”¨æ ‡å‡†çš„loadingï¼ˆä¼šè‡ªåŠ¨æ˜¾ç¤ºé®ç½©ï¼‰
            this.setLoading(true);
        }

        try {
            const requestData = {
                game_id: this.gameId,
                action: action,
                parameters: parameters
            };

            // è®°å½•è°ƒè¯•ä¿¡æ¯
            if (this.debugMode) {
                this.lastLLMRequest = {
                    timestamp: new Date().toISOString(),
                    action: action,
                    parameters: parameters,
                    game_id: this.gameId
                };
            }

            const response = await fetch('/api/action', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestData)
            });

            const result = await response.json();

            // è®°å½•å“åº”è°ƒè¯•ä¿¡æ¯
            if (this.debugMode) {
                this.lastLLMResponse = {
                    timestamp: new Date().toISOString(),
                    success: result.success,
                    message: result.message,
                    events: result.events,
                    narrative: result.narrative
                };
                this.updateDebugInfo();
            }
            
            if (result.success) {
                // æ£€æŸ¥åç«¯æ˜¯å¦æŒ‡ç¤ºéœ€è¦LLMé®ç½©ï¼ˆç”¨äºæ€ªç‰©æ”»å‡»ç­‰æƒ…å†µï¼‰
                const backendNeedsLLMOverlay = result.llm_interaction_required;
                let showedBackendOverlay = false;

                if (backendNeedsLLMOverlay && !needsSpecificLLMOverlay) {
                    this.showLLMOverlay('å¤„ç†ä¸­');
                    showedBackendOverlay = true;
                }

                // æ›´æ–°æ¸¸æˆçŠ¶æ€
                await this.refreshGameState();

                // æ·»åŠ æ¶ˆæ¯
                if (result.message) {
                    this.addMessage(result.message, 'action');
                }

                if (result.events) {
                    result.events.forEach(event => {
                        // æˆ˜æ–—ä¼¤å®³æ¶ˆæ¯ä½¿ç”¨ç‰¹æ®Šæ ·å¼
                        const messageType = event.includes('é€ æˆ') || event.includes('æ”»å‡»') ? 'combat' : 'system';
                        this.addMessage(event, messageType);
                    });
                }

                if (result.narrative) {
                    this.addMessage(result.narrative, 'narrative');
                }

                // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
                if (result.game_over) {
                    this.handleGameOver(result.game_over_reason);
                }

                // å¦‚æœæ˜¾ç¤ºäº†åç«¯æŒ‡ç¤ºçš„LLMé®ç½©ï¼Œç°åœ¨éšè—å®ƒ
                if (showedBackendOverlay) {
                    this.hideLLMOverlay();
                }
            } else {
                this.addMessage(result.message || 'è¡ŒåŠ¨å¤±è´¥', 'error');
            }
        } catch (error) {
            console.error('Action error:', error);
            this.addMessage('ç½‘ç»œé”™è¯¯ï¼Œè¯·é‡è¯•', 'error');
        } finally {
            // éšè—ç‰¹å®šçš„LLMé®ç½©
            if (needsSpecificLLMOverlay) {
                this.hideLLMOverlay();
                // é‡æ–°å¯ç”¨æ§åˆ¶æŒ‰é’®
                const controlButtons = document.querySelectorAll('.control-btn, .dir-btn');
                controlButtons.forEach(btn => {
                    btn.disabled = false;
                });
                this.isLoading = false;
            } else {
                // æ™®é€šæƒ…å†µï¼Œä½¿ç”¨æ ‡å‡†çš„setLoading(false)
                this.setLoading(false);
            }
        }
    }
    
    async refreshGameState() {
        if (!this.gameId) return;

        try {
            const response = await fetch(`/api/game/${this.gameId}`);
            const gameState = await response.json();

            this.gameState = gameState;
            this.updateUI();
        } catch (error) {
            console.error('Failed to refresh game state:', error);
        }
    }

    async loadConfig() {
        try {
            const response = await fetch('/api/config');
            const result = await response.json();
            this.config = result.config || result; // å…¼å®¹æ–°æ—§æ ¼å¼

            // æ›´æ–°è°ƒè¯•æ¨¡å¼çŠ¶æ€
            this.debugMode = this.config.game?.show_llm_debug || false;
            this.updateDebugFabVisibility();
        } catch (error) {
            console.error('Failed to load config:', error);
            this.config = {
                game: {
                    debug_mode: false,
                    show_llm_debug: false
                }
            }; // é»˜è®¤é…ç½®
        }
    }

    updateDebugFabVisibility() {
        const debugFab = document.getElementById('debug-fab');
        if (debugFab) {
            if (this.debugMode) {
                debugFab.classList.remove('hidden');
            } else {
                debugFab.classList.add('hidden');
            }
        }
    }
    
    updateUI() {
        if (!this.gameState) return;

        this.updateCharacterStats();
        this.updateMap();
        this.updateInventory();
        this.updateQuests();
        this.updateControlPanel();
        this.processPendingEffects();
    }

    renderGame() {
        this.updateUI();
    }

    processPendingEffects() {
        if (!this.gameState || !this.gameState.pending_effects) return;

        // å¤„ç†æ‰€æœ‰å¾…æ˜¾ç¤ºçš„ç‰¹æ•ˆ
        this.gameState.pending_effects.forEach(effect => {
            this.triggerEffect(effect);
        });

        // æ¸…ç©ºå·²å¤„ç†çš„ç‰¹æ•ˆ
        this.gameState.pending_effects = [];
    }

    triggerEffect(effect) {
        switch (effect.type) {
            case 'quest_completion':
                this.showQuestCompletionEffect(effect);
                break;
            default:
                console.log('Unknown effect type:', effect.type);
        }
    }

    showQuestCompletionEffect(effect) {
        // åˆ›å»ºä»»åŠ¡å®Œæˆç‰¹æ•ˆå®¹å™¨
        const effectContainer = document.createElement('div');
        effectContainer.className = 'quest-completion-effect';
        effectContainer.innerHTML = `
            <div class="quest-completion-content">
                <div class="quest-completion-icon">ğŸ‰</div>
                <div class="quest-completion-title">ä»»åŠ¡å®Œæˆï¼</div>
                <div class="quest-completion-quest-name">${effect.quest_title}</div>
                <div class="quest-completion-reward">è·å¾— ${effect.experience_reward} ç»éªŒå€¼</div>
                <div class="quest-completion-particles">
                    <div class="particle"></div>
                    <div class="particle"></div>
                    <div class="particle"></div>
                    <div class="particle"></div>
                    <div class="particle"></div>
                    <div class="particle"></div>
                    <div class="particle"></div>
                    <div class="particle"></div>
                </div>
            </div>
        `;

        // æ·»åŠ åˆ°é¡µé¢
        document.body.appendChild(effectContainer);

        // æ’­æ”¾éŸ³æ•ˆï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
        this.playQuestCompletionSound();

        // è‡ªåŠ¨ç§»é™¤ç‰¹æ•ˆ
        setTimeout(() => {
            effectContainer.classList.add('fade-out');
            setTimeout(() => {
                if (effectContainer.parentNode) {
                    effectContainer.parentNode.removeChild(effectContainer);
                }
            }, 1000);
        }, 4000);

        // æ·»åŠ æ¶ˆæ¯åˆ°æ—¥å¿—
        this.addMessage(effect.message, 'success');
    }

    playQuestCompletionSound() {
        // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ éŸ³æ•ˆæ’­æ”¾é€»è¾‘
        // ä¾‹å¦‚ä½¿ç”¨ Web Audio API æˆ–è€… HTML5 Audio
        try {
            // åˆ›å»ºä¸€ä¸ªç®€å•çš„æˆåŠŸéŸ³æ•ˆ
            if (typeof AudioContext !== 'undefined') {
                const audioContext = new AudioContext();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(523.25, audioContext.currentTime); // C5
                oscillator.frequency.setValueAtTime(659.25, audioContext.currentTime + 0.1); // E5
                oscillator.frequency.setValueAtTime(783.99, audioContext.currentTime + 0.2); // G5

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            }
        } catch (error) {
            // éŸ³æ•ˆæ’­æ”¾å¤±è´¥æ—¶é™é»˜å¤„ç†
            console.log('Audio playback not supported or failed');
        }
    }
    
    updateCharacterStats() {
        const player = this.gameState.player;
        const stats = player.stats;

        // æ›´æ–°åŸºç¡€ä¿¡æ¯
        document.getElementById('player-name').textContent = player.name;
        document.getElementById('player-level').textContent = stats.level;
        document.getElementById('player-class').textContent = player.character_class;

        // æ›´æ–°ç”Ÿå‘½å€¼
        document.getElementById('hp-current').textContent = stats.hp;
        document.getElementById('hp-max').textContent = stats.max_hp;
        const hpPercent = (stats.hp / stats.max_hp) * 100;
        document.getElementById('hp-bar').style.width = `${hpPercent}%`;

        // æ›´æ–°æ³•åŠ›å€¼
        document.getElementById('mp-current').textContent = stats.mp;
        document.getElementById('mp-max').textContent = stats.max_mp;
        const mpPercent = (stats.mp / stats.max_mp) * 100;
        document.getElementById('mp-bar').style.width = `${mpPercent}%`;

        // æ›´æ–°ç»éªŒå€¼
        const expNeeded = stats.level * 1000;
        const expPercent = (stats.experience / expNeeded) * 100;
        document.getElementById('exp-bar').style.width = `${expPercent}%`;
        document.getElementById('exp-text').textContent = `${stats.experience}/${expNeeded}`;

        // æ›´æ–°ä½ç½®
        document.getElementById('player-position').textContent =
            `(${player.position[0]}, ${player.position[1]})`;

        // æ›´æ–°æ¥¼å±‚ä¿¡æ¯
        if (this.gameState.current_map) {
            document.getElementById('player-floor').textContent = this.gameState.current_map.depth || 1;
            document.getElementById('current-map-name').textContent = this.gameState.current_map.name || 'æœªçŸ¥åŒºåŸŸ';
        }
    }
    
    updateMap() {
        const mapContainer = document.getElementById('map-grid');
        const gameMap = this.gameState.current_map;
        const player = this.gameState.player;
        
        // è®¾ç½®ç½‘æ ¼æ ·å¼
        mapContainer.style.gridTemplateColumns = `repeat(${gameMap.width}, 24px)`;
        mapContainer.innerHTML = '';
        
        // åˆ›å»ºåœ°å›¾ç“¦ç‰‡
        for (let y = 0; y < gameMap.height; y++) {
            for (let x = 0; x < gameMap.width; x++) {
                const tileKey = `${x},${y}`;
                const tileData = gameMap.tiles[tileKey];
                
                const tile = document.createElement('div');
                tile.className = 'map-tile';
                tile.dataset.x = x;
                tile.dataset.y = y;

                // æ·»åŠ æ‚¬åœäº‹ä»¶
                tile.addEventListener('mouseenter', (e) => {
                    this.showTileTooltip(e, tileData, x, y);
                    this.handleTileHover(x, y, tileData, true);
                });

                tile.addEventListener('mouseleave', () => {
                    this.hideTileTooltip();
                    this.handleTileHover(x, y, tileData, false);
                });

                // æ·»åŠ ç‚¹å‡»ç§»åŠ¨äº‹ä»¶
                tile.addEventListener('click', () => {
                    this.handleTileClick(x, y, tileData);
                });
                
                if (tileData) {
                    // è®¾ç½®åœ°å½¢æ ·å¼
                    tile.classList.add(`terrain-${tileData.terrain}`);

                    // è®¾ç½®æˆ¿é—´ç±»å‹æ ·å¼
                    if (tileData.room_type) {
                        tile.classList.add(`room-${tileData.room_type}`);

                        // ä¸ºç‰¹æ®Šç±»å‹çš„é—¨æ·»åŠ é¢å¤–æ ·å¼
                        if (tileData.terrain === 'door') {
                            if (tileData.room_type === 'treasure') {
                                tile.classList.add('door-treasure');
                            } else if (tileData.room_type === 'boss') {
                                tile.classList.add('door-boss');
                            } else if (tileData.room_type === 'special') {
                                tile.classList.add('door-special');
                            }
                        }
                    }

                    // è®¾ç½®å¯è§æ€§
                    if (tileData.is_explored) {
                        tile.classList.add('tile-explored');
                    } else {
                        tile.classList.add('tile-unexplored');
                    }

                    if (tileData.is_visible) {
                        tile.classList.add('tile-visible');
                    }

                    // æ£€æŸ¥æ˜¯å¦ä¸ºä»»åŠ¡äº‹ä»¶
                    if (tileData.has_event && tileData.event_data && tileData.event_data.quest_event_id) {
                        tile.classList.add('quest-event');
                    }
                    
                    // æ·»åŠ è§’è‰²
                    if (tileData.character_id === player.id) {
                        const playerIcon = document.createElement('div');
                        playerIcon.className = 'character-player';
                        tile.appendChild(playerIcon);
                    } else if (tileData.character_id) {
                        // æŸ¥æ‰¾æ€ªç‰©
                        const monster = this.gameState.monsters.find(m => m.id === tileData.character_id);
                        if (monster) {
                            const monsterIcon = document.createElement('div');
                            monsterIcon.className = 'character-monster';

                            // æ£€æŸ¥æ˜¯å¦ä¸ºä»»åŠ¡æ€ªç‰©
                            if (this.isQuestMonster(monster)) {
                                if (monster.is_boss) {
                                    monsterIcon.classList.add('quest-boss');
                                } else {
                                    monsterIcon.classList.add('quest-monster');
                                }
                            }

                            monsterIcon.title = monster.name;
                            monsterIcon.addEventListener('click', () => {
                                this.attackMonster(monster.id);
                            });
                            tile.appendChild(monsterIcon);
                        }
                    }
                }
                
                mapContainer.appendChild(tile);
            }
        }
    }
    
    updateInventory() {
        const inventoryGrid = document.getElementById('inventory-grid');
        const inventory = this.gameState.player.inventory;

        inventoryGrid.innerHTML = '';

        // åˆ›å»ºç‰©å“æ æ ¼å­ï¼ˆ4x4ï¼‰
        for (let i = 0; i < 16; i++) {
            const slot = document.createElement('div');
            slot.className = 'inventory-slot';
            slot.dataset.slot = i;

            if (i < inventory.length) {
                const item = inventory[i];
                slot.classList.add('has-item');
                slot.title = `${item.name}\n${item.description}`;
                slot.textContent = item.name.charAt(0).toUpperCase();

                slot.addEventListener('click', () => {
                    this.showItemUseDialog(item);
                });
            }

            inventoryGrid.appendChild(slot);
        }
    }
    
    updateQuests() {
        const questList = document.getElementById('quest-list');
        const quests = this.gameState.quests.filter(q => q.is_active);

        questList.innerHTML = '';

        quests.forEach(quest => {
            const questElement = document.createElement('div');
            questElement.className = 'quest-item';

            // æ„å»ºä»»åŠ¡HTML
            let questHTML = `
                <h4>${quest.title}</h4>
                <p>${quest.description}</p>
            `;

            // æ ¹æ®é…ç½®æ˜¾ç¤ºè¿›åº¦ç™¾åˆ†æ¯”
            const showProgress = this.config &&
                                (this.config.show_quest_progress ||
                                 (this.config.game && this.config.game.show_quest_progress));

            if (showProgress && quest.progress_percentage !== undefined) {
                questHTML += `
                    <div class="quest-progress">
                        <div class="progress-bar-small">
                            <div class="progress-fill-small" style="width: ${quest.progress_percentage}%"></div>
                        </div>
                        <span class="progress-text-small">è¿›åº¦: ${quest.progress_percentage.toFixed(1)}%</span>
                    </div>
                `;
            }

            questHTML += `
                <div class="quest-objectives">
                    ${quest.objectives.map((obj, index) =>
                        `<div class="objective ${quest.completed_objectives[index] ? 'completed' : ''}">
                            ${quest.completed_objectives[index] ? 'âœ“' : 'â—‹'} ${obj}
                        </div>`
                    ).join('')}
                </div>
            `;

            questElement.innerHTML = questHTML;
            questList.appendChild(questElement);
        });
    }
    
    async attackMonster(monsterId) {
        await this.performAction('attack', { target_id: monsterId });
    }

    isQuestMonster(monster) {
        // æ£€æŸ¥æ€ªç‰©æ˜¯å¦ä¸ºä»»åŠ¡ç›¸å…³æ€ªç‰©
        if (!this.gameState.quests || this.gameState.quests.length === 0) {
            return false;
        }

        // æŸ¥æ‰¾æ´»è·ƒä»»åŠ¡
        const activeQuest = this.gameState.quests.find(q => q.is_active && !q.is_completed);
        if (!activeQuest || !activeQuest.special_monsters) {
            return false;
        }

        // æ£€æŸ¥æ€ªç‰©åç§°æ˜¯å¦åŒ¹é…ä»»åŠ¡ä¸“å±æ€ªç‰©
        return activeQuest.special_monsters.some(questMonster =>
            monster.name === questMonster.name ||
            monster.name.includes(questMonster.name) ||
            questMonster.name.includes(monster.name)
        );
    }

    handleTileClick(x, y, tileData) {
        if (this.isLoading) return;

        const player = this.gameState.player;
        const playerX = player.position[0];
        const playerY = player.position[1];

        // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†æ€ªç‰©
        if (tileData.character_id && tileData.character_id !== player.id) {
            const monster = this.gameState.monsters.find(m => m.id === tileData.character_id);
            if (monster) {
                // æ£€æŸ¥æ”»å‡»è·ç¦»ï¼ˆä½¿ç”¨åˆ‡æ¯”é›ªå¤«è·ç¦»ï¼Œå…è®¸å¯¹è§’çº¿æ”»å‡»ï¼‰
                const distance = Math.max(Math.abs(x - playerX), Math.abs(y - playerY));
                if (distance <= 1) {  // ç©å®¶åªèƒ½è¿‘æˆ˜æ”»å‡»
                    this.attackMonster(monster.id);
                    return;
                } else {
                    this.addMessage('ç›®æ ‡è·ç¦»å¤ªè¿œï¼Œæ— æ³•æ”»å‡»', 'error');
                    return;
                }
            }
        }

        // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç§»åŠ¨åˆ°è¯¥ä½ç½®
        if (this.canMoveToTile(x, y, playerX, playerY)) {
            this.moveToPosition(x, y);
        }
    }

    canMoveToTile(targetX, targetY, playerX, playerY, showMessages = true) {
        // æ£€æŸ¥æ˜¯å¦ä¸ºç›¸é‚»æ ¼å­ï¼ˆåŒ…æ‹¬å¯¹è§’çº¿ï¼‰
        const dx = Math.abs(targetX - playerX);
        const dy = Math.abs(targetY - playerY);

        if (dx > 1 || dy > 1 || (dx === 0 && dy === 0)) {
            return false;
        }

        // æ£€æŸ¥ç›®æ ‡ç“¦ç‰‡
        const tileKey = `${targetX},${targetY}`;
        const tileData = this.gameState.current_map.tiles[tileKey];

        if (!tileData) {
            return false;
        }

        // æ£€æŸ¥åœ°å½¢
        if (tileData.terrain === 'wall') {
            if (showMessages) {
                this.addMessage('æ— æ³•ç©¿è¿‡å¢™å£', 'error');
            }
            return false;
        }

        // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–è§’è‰²
        if (tileData.character_id && tileData.character_id !== this.gameState.player.id) {
            if (showMessages) {
                this.addMessage('è¯¥ä½ç½®å·²è¢«å æ®', 'error');
            }
            return false;
        }

        return true;
    }

    async moveToPosition(x, y) {
        const playerX = this.gameState.player.position[0];
        const playerY = this.gameState.player.position[1];

        // è®¡ç®—ç§»åŠ¨æ–¹å‘
        const dx = x - playerX;
        const dy = y - playerY;

        let direction = '';
        if (dx === 0 && dy === -1) direction = 'north';
        else if (dx === 0 && dy === 1) direction = 'south';
        else if (dx === -1 && dy === 0) direction = 'west';
        else if (dx === 1 && dy === 0) direction = 'east';
        else if (dx === -1 && dy === -1) direction = 'northwest';
        else if (dx === 1 && dy === -1) direction = 'northeast';
        else if (dx === -1 && dy === 1) direction = 'southwest';
        else if (dx === 1 && dy === 1) direction = 'southeast';

        if (direction) {
            await this.movePlayer(direction);
        }
    }
    
    showItemUseDialog(item) {
        const dialog = document.getElementById('item-use-dialog');
        const nameElement = document.getElementById('item-use-name');
        const descriptionElement = document.getElementById('item-use-description');
        const usageElement = document.getElementById('item-use-usage');
        const confirmButton = document.getElementById('confirm-use-item');
        const dropButton = document.getElementById('drop-item');
        const cancelButton = document.getElementById('cancel-use-item');

        // å¡«å……ç‰©å“ä¿¡æ¯
        nameElement.textContent = item.name;
        descriptionElement.textContent = item.description;
        usageElement.textContent = item.usage_description || 'ä½¿ç”¨æ–¹æ³•æœªçŸ¥';

        // è®¾ç½®æŒ‰é’®äº‹ä»¶
        confirmButton.onclick = () => {
            this.hideItemUseDialog();
            this.useItem(item.id);
        };

        dropButton.onclick = () => {
            this.hideItemUseDialog();
            this.dropItem(item.id);
        };

        cancelButton.onclick = () => {
            this.hideItemUseDialog();
        };

        // æ˜¾ç¤ºå¯¹è¯æ¡†
        dialog.style.display = 'flex';
    }

    hideItemUseDialog() {
        const dialog = document.getElementById('item-use-dialog');
        dialog.style.display = 'none';
    }

    async useItem(itemId) {
        await this.performAction('use_item', { item_id: itemId });
    }

    async dropItem(itemId) {
        await this.performAction('drop_item', { item_id: itemId });
    }

    showTileTooltip(event, tileData, x, y) {
        const tooltip = document.getElementById('tile-tooltip');
        if (!tooltip) return;

        let tooltipText = `ä½ç½®: (${x}, ${y})\n`;

        if (tileData) {
            // åœ°å½¢ä¿¡æ¯
            const terrainNames = {
                'floor': 'åœ°æ¿',
                'wall': 'å¢™å£',
                'door': 'é—¨',
                'trap': 'é™·é˜±',
                'treasure': 'å®è—',
                'stairs_up': 'ä¸Šæ¥¼æ¢¯',
                'stairs_down': 'ä¸‹æ¥¼æ¢¯',
                'water': 'æ°´',
                'lava': 'å²©æµ†',
                'pit': 'æ·±å‘'
            };

            tooltipText += `åœ°å½¢: ${terrainNames[tileData.terrain] || tileData.terrain}\n`;

            // æˆ¿é—´ç±»å‹ä¿¡æ¯
            if (tileData.room_type) {
                const roomTypeNames = {
                    'entrance': 'å…¥å£æˆ¿é—´',
                    'treasure': 'å®åº“æˆ¿é—´',
                    'boss': 'Bossæˆ¿é—´',
                    'special': 'ç‰¹æ®Šæˆ¿é—´',
                    'normal': 'æ™®é€šæˆ¿é—´',
                    'corridor': 'èµ°å»Š'
                };
                tooltipText += `æˆ¿é—´ç±»å‹: ${roomTypeNames[tileData.room_type] || tileData.room_type}\n`;
            }

            // æ¢ç´¢çŠ¶æ€
            if (tileData.is_explored) {
                tooltipText += 'çŠ¶æ€: å·²æ¢ç´¢\n';
            } else {
                tooltipText += 'çŠ¶æ€: æœªæ¢ç´¢\n';
            }

            // è§’è‰²ä¿¡æ¯
            if (tileData.character_id) {
                if (tileData.character_id === this.gameState.player.id) {
                    const player = this.gameState.player;
                    tooltipText += `è§’è‰²: ${player.name} (ç©å®¶)\n`;
                    tooltipText += `ç”Ÿå‘½å€¼: ${player.stats.hp}/${player.stats.max_hp}\n`;
                    tooltipText += `æ³•åŠ›å€¼: ${player.stats.mp}/${player.stats.max_mp}\n`;
                    tooltipText += `ç­‰çº§: ${player.stats.level}\n`;
                } else {
                    const monster = this.gameState.monsters.find(m => m.id === tileData.character_id);
                    if (monster) {
                        // æ£€æŸ¥æ˜¯å¦ä¸ºä»»åŠ¡æ€ªç‰©
                        const isQuestMonster = this.isQuestMonster(monster);

                        if (isQuestMonster) {
                            if (monster.is_boss) {
                                tooltipText += `ä»»åŠ¡Boss: ${monster.name} ğŸ‘‘\n`;
                            } else {
                                tooltipText += `ä»»åŠ¡æ€ªç‰©: ${monster.name} â­\n`;
                            }
                        } else {
                            tooltipText += `æ€ªç‰©: ${monster.name}\n`;
                        }

                        tooltipText += `ç”Ÿå‘½å€¼: ${monster.stats.hp}/${monster.stats.max_hp}\n`;
                        if (monster.challenge_rating) {
                            tooltipText += `æŒ‘æˆ˜ç­‰çº§: ${monster.challenge_rating}\n`;
                        }

                        // æ˜¾ç¤ºæ”»å‡»èŒƒå›´ä¿¡æ¯
                        const attackRange = monster.attack_range || 1;
                        if (attackRange > 1) {
                            tooltipText += `æ”»å‡»èŒƒå›´: ${attackRange} (è¿œç¨‹æ”»å‡»)\n`;
                        } else {
                            tooltipText += `æ”»å‡»èŒƒå›´: ${attackRange} (è¿‘æˆ˜æ”»å‡»)\n`;
                        }

                        // å¦‚æœæ˜¯ä»»åŠ¡æ€ªç‰©ï¼Œæ˜¾ç¤ºé¢å¤–ä¿¡æ¯
                        if (isQuestMonster) {
                            tooltipText += `ç±»å‹: ä»»åŠ¡ç›¸å…³æ•Œäºº\n`;
                            if (monster.is_boss) {
                                tooltipText += `è­¦å‘Š: å¼ºå¤§çš„Bossæ•Œäººï¼\n`;
                            }
                        }
                    }
                }
            }

            // ç‰©å“ä¿¡æ¯
            if (tileData.items && tileData.items.length > 0) {
                tooltipText += `ç‰©å“: ${tileData.items.length}ä¸ª\n`;
            }

            // äº‹ä»¶ä¿¡æ¯ï¼ˆå¦‚æœæœ‰ä¸”ä¸éšè—ï¼‰
            if (tileData.has_event && !tileData.is_event_hidden) {
                const eventNames = {
                    'combat': 'æˆ˜æ–—',
                    'treasure': 'å®è—',
                    'story': 'æ•…äº‹',
                    'trap': 'é™·é˜±',
                    'mystery': 'ç¥ç§˜'
                };

                // æ£€æŸ¥æ˜¯å¦ä¸ºä»»åŠ¡äº‹ä»¶
                if (tileData.event_data && tileData.event_data.quest_event_id) {
                    tooltipText += `ä»»åŠ¡äº‹ä»¶: ${tileData.event_data.name || 'ç‰¹æ®Šäº‹ä»¶'}\n`;
                    if (tileData.event_data.description) {
                        tooltipText += `æè¿°: ${tileData.event_data.description}\n`;
                    }
                    if (tileData.event_data.is_mandatory) {
                        tooltipText += 'ç±»å‹: å¿…è¦ä»»åŠ¡äº‹ä»¶\n';
                    }
                } else {
                    tooltipText += `äº‹ä»¶: ${eventNames[tileData.event_type] || tileData.event_type}\n`;
                }

                if (tileData.event_triggered) {
                    tooltipText += 'çŠ¶æ€: å·²è§¦å‘\n';
                } else {
                    tooltipText += 'çŠ¶æ€: æœªè§¦å‘\n';
                }
            }
        } else {
            tooltipText += 'åœ°å½¢: æœªçŸ¥\n';
        }

        tooltip.textContent = tooltipText.trim();
        tooltip.classList.add('show');

        // å®šä½å·¥å…·æç¤º
        const rect = event.target.getBoundingClientRect();
        tooltip.style.left = `${rect.left + rect.width / 2}px`;
        tooltip.style.top = `${rect.top - tooltip.offsetHeight - 10}px`;

        // ç¡®ä¿å·¥å…·æç¤ºä¸è¶…å‡ºå±å¹•è¾¹ç•Œ
        const tooltipRect = tooltip.getBoundingClientRect();
        if (tooltipRect.left < 0) {
            tooltip.style.left = '10px';
        }
        if (tooltipRect.right > window.innerWidth) {
            tooltip.style.left = `${window.innerWidth - tooltipRect.width - 10}px`;
        }
        if (tooltipRect.top < 0) {
            tooltip.style.top = `${rect.bottom + 10}px`;
        }
    }

    hideTileTooltip() {
        const tooltip = document.getElementById('tile-tooltip');
        if (tooltip) {
            tooltip.classList.remove('show');
        }
    }
    
    addMessage(text, type = 'system') {
        const messageLog = document.getElementById('message-log');
        const message = document.createElement('div');
        message.className = `message message-${type}`;
        message.textContent = text;
        
        messageLog.appendChild(message);
        messageLog.scrollTop = messageLog.scrollHeight;
        
        // é™åˆ¶æ¶ˆæ¯æ•°é‡
        while (messageLog.children.length > 50) {
            messageLog.removeChild(messageLog.firstChild);
        }
    }
    
    setLoading(loading) {
        this.isLoading = loading;
        const loadingElements = document.querySelectorAll('.loading-indicator');
        loadingElements.forEach(el => {
            el.style.display = loading ? 'inline-block' : 'none';
        });

        // ç¦ç”¨/å¯ç”¨æ§åˆ¶æŒ‰é’®
        const controlButtons = document.querySelectorAll('.control-btn, .dir-btn');
        controlButtons.forEach(btn => {
            btn.disabled = loading;
        });

        // å½“æ˜¾ç¤º"å¤„ç†ä¸­..."æ—¶ï¼Œè‡ªåŠ¨æ˜¾ç¤ºLLMé®ç½©
        if (loading) {
            // æ£€æŸ¥æ˜¯å¦å·²ç»æœ‰é®ç½©æ˜¾ç¤ºï¼Œé¿å…é‡å¤æ˜¾ç¤º
            const existingOverlay = document.getElementById('partial-overlay');
            if (!existingOverlay || existingOverlay.style.display === 'none') {
                this.showLLMOverlay('å¤„ç†ä¸­');
            }
        } else {
            // å½“loadingç»“æŸæ—¶ï¼Œéšè—LLMé®ç½©
            this.hideLLMOverlay();
        }
    }

    showFullscreenOverlay(title, subtitle, status = '') {
        const overlay = document.getElementById('fullscreen-overlay');
        const titleEl = document.getElementById('overlay-title');
        const subtitleEl = document.getElementById('overlay-subtitle');
        const statusEl = document.getElementById('overlay-status');
        const progressBar = document.getElementById('overlay-progress-bar');

        if (overlay && titleEl && subtitleEl && statusEl) {
            titleEl.textContent = title;
            subtitleEl.textContent = subtitle;
            statusEl.textContent = status;
            progressBar.style.width = '0%';
            overlay.classList.add('show');
        }
    }

    hideFullscreenOverlay() {
        const overlay = document.getElementById('fullscreen-overlay');
        if (overlay) {
            overlay.classList.remove('show');
        }
    }

    updateOverlayProgress(progress, status = '') {
        const progressBar = document.getElementById('overlay-progress-bar');
        const statusEl = document.getElementById('overlay-status');

        if (progressBar) {
            progressBar.style.width = `${Math.min(100, Math.max(0, progress))}%`;
        }

        if (statusEl && status) {
            statusEl.textContent = status;
        }
    }

    showLLMOverlay(action = 'æ€è€ƒä¸­') {
        const titles = {
            'move': 'AI æ­£åœ¨åˆ†æç¯å¢ƒ',
            'attack': 'AI æ­£åœ¨è®¡ç®—æˆ˜æ–—',
            'interact': 'AI æ­£åœ¨å¤„ç†äº¤äº’',
            'rest': 'AI æ­£åœ¨æ¢å¤çŠ¶æ€',
            'default': 'AI æ­£åœ¨æ€è€ƒ'
        };

        const subtitles = {
            'move': 'åˆ†æåœ°å½¢å’Œæ½œåœ¨å¨èƒ...',
            'attack': 'è®¡ç®—æœ€ä½³æ”»å‡»ç­–ç•¥...',
            'interact': 'ç†è§£ç¯å¢ƒä¸­çš„å…ƒç´ ...',
            'rest': 'è¯„ä¼°ä¼‘æ¯çš„å®‰å…¨æ€§...',
            'default': 'å¤„ç†æ‚¨çš„è¯·æ±‚...'
        };

        const title = titles[action] || titles['default'];
        const subtitle = subtitles[action] || subtitles['default'];

        // ä½¿ç”¨æ–°çš„éƒ¨åˆ†é®ç½©è€Œä¸æ˜¯å…¨å±é®ç½©
        this.showPartialOverlay(title, subtitle, 'æ­£åœ¨ä¸AIé€šä¿¡...');

        // æ¨¡æ‹Ÿè¿›åº¦æ›´æ–°
        let progress = 0;
        const progressInterval = setInterval(() => {
            progress += Math.random() * 15;
            if (progress >= 90) {
                progress = 90;
                clearInterval(progressInterval);
            }
            this.updateOverlayProgress(progress);
        }, 200);

        // å­˜å‚¨intervalä»¥ä¾¿åç»­æ¸…ç†
        this.currentProgressInterval = progressInterval;
    }

    hideLLMOverlay() {
        if (this.currentProgressInterval) {
            clearInterval(this.currentProgressInterval);
            this.currentProgressInterval = null;
        }

        // å®Œæˆè¿›åº¦æ¡
        this.updateOverlayProgress(100, 'å®Œæˆï¼');

        // å»¶è¿Ÿéšè—ä»¥æ˜¾ç¤ºå®ŒæˆçŠ¶æ€
        setTimeout(() => {
            this.hidePartialOverlay();
        }, 500);
    }

    shouldShowLLMOverlay(action, parameters) {
        // æ£€æŸ¥æ˜¯å¦éœ€è¦æ˜¾ç¤ºLLMé®ç½©
        // ä¸»è¦åœ¨ä»¥ä¸‹æƒ…å†µæ˜¾ç¤ºï¼š
        // 1. ç§»åŠ¨åˆ°ç‰¹æ®Šåœ°å½¢ï¼ˆä½†ä¸åŒ…æ‹¬æ¥¼æ¢¯ï¼Œæ¥¼æ¢¯åªæ˜¯æç¤ºï¼‰
        // 2. äº¤äº’è¡ŒåŠ¨
        // 3. æ”»å‡»è¡ŒåŠ¨
        // 4. ä¼‘æ¯æ—¶å¯èƒ½è§¦å‘äº‹ä»¶

        if (action === 'interact') {
            return true;
        }

        if (action === 'attack') {
            return true;
        }

        if (action === 'move') {
            // æ£€æŸ¥ç›®æ ‡ä½ç½®æ˜¯å¦æœ‰ç‰¹æ®Šåœ°å½¢
            const direction = parameters.direction;
            if (this.gameState && this.gameState.player) {
                const player = this.gameState.player;
                const currentX = player.position[0];
                const currentY = player.position[1];

                // è®¡ç®—ç›®æ ‡ä½ç½®
                const directionMap = {
                    "north": [0, -1], "south": [0, 1],
                    "east": [1, 0], "west": [-1, 0],
                    "northeast": [1, -1], "northwest": [-1, -1],
                    "southeast": [1, 1], "southwest": [-1, 1]
                };

                if (direction && directionMap[direction]) {
                    const [dx, dy] = directionMap[direction];
                    const targetX = currentX + dx;
                    const targetY = currentY + dy;
                    const tileKey = `${targetX},${targetY}`;
                    const targetTile = this.gameState.current_map.tiles[tileKey];

                    if (targetTile) {
                        // ç‰¹æ®Šåœ°å½¢éœ€è¦LLMå¤„ç†ï¼ˆæ¥¼æ¢¯é™¤å¤–ï¼Œæ¥¼æ¢¯åªæ˜¯è®¾ç½®å¾…åˆ‡æ¢çŠ¶æ€ï¼‰
                        const llmRequiredTerrains = ['trap', 'treasure', 'door'];
                        if (llmRequiredTerrains.includes(targetTile.terrain) || targetTile.has_event) {
                            return true;
                        }
                    }
                }
            }
        }

        if (action === 'rest') {
            // ä¼‘æ¯æ—¶å¯èƒ½è§¦å‘éšæœºäº‹ä»¶
            return Math.random() < 0.3; // 30%æ¦‚ç‡æ˜¾ç¤ºé®ç½©
        }

        return false;
    }

    handleTileHover(x, y, tileData, isEntering) {
        if (!this.gameState || !this.gameState.player) return;

        const player = this.gameState.player;
        const playerX = player.position[0];
        const playerY = player.position[1];

        if (isEntering) {
            // æ¸…é™¤ä¹‹å‰çš„é«˜äº®
            this.clearTileHighlights();

            // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç§»åŠ¨åˆ°è¯¥ä½ç½®ï¼ˆä¸æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯ï¼‰
            if (this.canMoveToTile(x, y, playerX, playerY, false)) {
                this.highlightMovableTile(x, y);
                this.highlightMovementPath(playerX, playerY, x, y);
            }

            // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ”»å‡»è¯¥ä½ç½®çš„æ€ªç‰©
            if (tileData && tileData.character_id && tileData.character_id !== player.id) {
                const monster = this.gameState.monsters.find(m => m.id === tileData.character_id);
                if (monster) {
                    const distance = Math.max(Math.abs(x - playerX), Math.abs(y - playerY));
                    if (distance <= 1) {  // ç©å®¶åªèƒ½è¿‘æˆ˜æ”»å‡»
                        this.highlightAttackableTile(x, y);
                    }
                }
            }

            this.hoveredTile = { x, y };
        } else {
            // é¼ æ ‡ç¦»å¼€æ—¶æ¸…é™¤é«˜äº®
            this.clearTileHighlights();
            this.hoveredTile = null;
        }
    }

    highlightMovableTile(x, y) {
        const tile = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
        if (tile) {
            tile.classList.add('movable');
            this.highlightedTiles.push({ element: tile, type: 'movable' });
        }
    }

    highlightAttackableTile(x, y) {
        const tile = document.querySelector(`[data-x="${x}"][data-y="${y}"]`);
        if (tile) {
            tile.classList.add('attackable');
            this.highlightedTiles.push({ element: tile, type: 'attackable' });
        }
    }

    highlightMovementPath(fromX, fromY, toX, toY) {
        // ç®€å•çš„ç›´çº¿è·¯å¾„é«˜äº®ï¼ˆå¯ä»¥æ‰©å±•ä¸ºæ›´å¤æ‚çš„å¯»è·¯ç®—æ³•ï¼‰
        const dx = toX - fromX;
        const dy = toY - fromY;

        // å¯¹äºç›¸é‚»ç“¦ç‰‡ï¼Œä¸éœ€è¦è·¯å¾„é«˜äº®
        if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1) {
            return;
        }

        // è®¡ç®—è·¯å¾„ä¸Šçš„ç“¦ç‰‡
        const steps = Math.max(Math.abs(dx), Math.abs(dy));
        for (let i = 1; i < steps; i++) {
            const pathX = Math.round(fromX + (dx * i / steps));
            const pathY = Math.round(fromY + (dy * i / steps));

            const pathTile = document.querySelector(`[data-x="${pathX}"][data-y="${pathY}"]`);
            if (pathTile) {
                pathTile.classList.add('path-highlight');
                this.highlightedTiles.push({ element: pathTile, type: 'path' });
            }
        }
    }

    clearTileHighlights() {
        this.highlightedTiles.forEach(({ element }) => {
            element.classList.remove('movable', 'attackable', 'path-highlight');
        });
        this.highlightedTiles = [];
    }
    
    async saveGame() {
        if (!this.gameId || this.isLoading) return;
        
        this.setLoading(true);
        
        try {
            const response = await fetch(`/api/save/${this.gameId}`, {
                method: 'POST'
            });
            
            const result = await response.json();
            
            if (result.success) {
                this.addMessage('æ¸¸æˆå·²ä¿å­˜', 'success');
            } else {
                this.addMessage('ä¿å­˜å¤±è´¥', 'error');
            }
        } catch (error) {
            console.error('Save error:', error);
            this.addMessage('ä¿å­˜æ—¶å‘ç”Ÿé”™è¯¯', 'error');
        } finally {
            this.setLoading(false);
        }
    }
    
    async loadGameList() {
        try {
            const response = await fetch('/api/saves');
            const saves = await response.json();
            
            const savesList = document.getElementById('saves-list');
            if (savesList) {
                savesList.innerHTML = '';
                
                saves.forEach(save => {
                    const saveElement = document.createElement('div');
                    saveElement.className = 'save-item';
                    saveElement.innerHTML = `
                        <h4>${save.player_name} (ç­‰çº§ ${save.player_level})</h4>
                        <p>${save.map_name} - å›åˆ ${save.turn_count}</p>
                        <p>æœ€åä¿å­˜: ${new Date(save.last_saved).toLocaleString()}</p>
                        <button onclick="game.loadGame('${save.id}')">åŠ è½½</button>
                        <button onclick="game.deleteGame('${save.id}')">åˆ é™¤</button>
                    `;
                    savesList.appendChild(saveElement);
                });
            }
        } catch (error) {
            console.error('Failed to load game list:', error);
        }
    }
    
    async loadGame(saveId) {
        this.setLoading(true);
        this.showFullscreenOverlay('åŠ è½½å­˜æ¡£', 'æ­£åœ¨è¯»å–æ‚¨çš„å†’é™©è¿›åº¦...', 'è¿æ¥åˆ°æ¸¸æˆæœåŠ¡å™¨...');

        try {
            this.updateOverlayProgress(20, 'éªŒè¯å­˜æ¡£æ–‡ä»¶...');

            const response = await fetch(`/api/load/${saveId}`, {
                method: 'POST'
            });

            this.updateOverlayProgress(50, 'è§£ææ¸¸æˆæ•°æ®...');
            const result = await response.json();

            if (result.success) {
                this.updateOverlayProgress(70, 'é‡å»ºæ¸¸æˆä¸–ç•Œ...');
                this.gameId = result.game_id;

                this.updateOverlayProgress(85, 'åŠ è½½è§’è‰²çŠ¶æ€...');
                await this.refreshGameState();

                this.updateOverlayProgress(95, 'å‡†å¤‡æ¸¸æˆç•Œé¢...');
                this.addMessage('æ¸¸æˆå·²åŠ è½½', 'success');

                // æ˜¾ç¤ºå™è¿°æ–‡æœ¬
                if (result.narrative) {
                    this.addMessage(result.narrative, 'narrative');
                }

                this.updateOverlayProgress(100, 'åŠ è½½å®Œæˆï¼');

                // å»¶è¿Ÿä¸€ä¸‹æ˜¾ç¤ºå®ŒæˆçŠ¶æ€
                await new Promise(resolve => setTimeout(resolve, 800));

                // éšè—ä¸»èœå•ï¼Œæ˜¾ç¤ºæ¸¸æˆç•Œé¢
                document.getElementById('main-menu').style.display = 'none';
                document.getElementById('game-interface').style.display = 'block';

                this.hideFullscreenOverlay();
            } else {
                this.addMessage('åŠ è½½å¤±è´¥', 'error');
                this.hideFullscreenOverlay();
            }
        } catch (error) {
            console.error('Load error:', error);
            this.addMessage('åŠ è½½æ—¶å‘ç”Ÿé”™è¯¯', 'error');
            this.hideFullscreenOverlay();
        } finally {
            this.setLoading(false);
        }
    }

    async deleteGame(saveId) {
        // æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
        if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªå­˜æ¡£å—ï¼Ÿæ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚')) {
            return;
        }

        this.setLoading(true);

        try {
            const response = await fetch(`/api/save/${saveId}`, {
                method: 'DELETE'
            });

            const result = await response.json();

            if (result.success) {
                this.addMessage('å­˜æ¡£å·²åˆ é™¤', 'success');
                // åˆ·æ–°å­˜æ¡£åˆ—è¡¨
                await this.loadGameList();
            } else {
                this.addMessage('åˆ é™¤å¤±è´¥', 'error');
            }
        } catch (error) {
            console.error('Delete error:', error);
            this.addMessage('åˆ é™¤æ—¶å‘ç”Ÿé”™è¯¯', 'error');
        } finally {
            this.setLoading(false);
        }
    }
    
    showNewGameModal() {
        document.getElementById('new-game-modal').style.display = 'block';
    }
    
    async createNewGame() {
        const playerName = document.getElementById('player-name-input').value.trim();
        const characterClass = document.getElementById('character-class-select').value;

        if (!playerName) {
            alert('è¯·è¾“å…¥è§’è‰²åç§°');
            return;
        }

        this.setLoading(true);
        this.showFullscreenOverlay('åˆ›å»ºæ–°æ¸¸æˆ', 'æ­£åœ¨ä¸ºæ‚¨ç”Ÿæˆç‹¬ç‰¹çš„å†’é™©ä¸–ç•Œï¼ˆä¸€èˆ¬ç­‰20så³å¯ï¼‰...', 'åˆå§‹åŒ–AIç³»ç»Ÿ...');

        try {
            this.updateOverlayProgress(15, 'åˆ›å»ºè§’è‰²æ¡£æ¡ˆ...');

            const response = await fetch('/api/new-game', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    player_name: playerName,
                    character_class: characterClass
                })
            });

            this.updateOverlayProgress(40, 'AIæ­£åœ¨ç”Ÿæˆåœ°ä¸‹åŸ...');
            const result = await response.json();

            if (result.success) {
                this.updateOverlayProgress(65, 'æ„å»ºæ¸¸æˆä¸–ç•Œ...');
                this.gameId = result.game_id;

                this.updateOverlayProgress(80, 'åŠ è½½è§’è‰²æ•°æ®...');
                await this.refreshGameState();

                this.updateOverlayProgress(90, 'ç”Ÿæˆå¼€åœºæ•…äº‹...');
                this.addMessage('æ–°æ¸¸æˆå¼€å§‹ï¼', 'success');

                // æ˜¾ç¤ºå™è¿°æ–‡æœ¬
                if (result.narrative) {
                    this.addMessage(result.narrative, 'narrative');
                }

                this.updateOverlayProgress(100, 'å‡†å¤‡å°±ç»ªï¼');

                // å»¶è¿Ÿæ˜¾ç¤ºå®ŒæˆçŠ¶æ€
                await new Promise(resolve => setTimeout(resolve, 1000));

                // éšè—æ¨¡æ€æ¡†å’Œä¸»èœå•ï¼Œæ˜¾ç¤ºæ¸¸æˆç•Œé¢
                document.getElementById('new-game-modal').style.display = 'none';
                document.getElementById('main-menu').style.display = 'none';
                document.getElementById('game-interface').style.display = 'block';

                this.hideFullscreenOverlay();
            } else {
                this.addMessage('åˆ›å»ºæ¸¸æˆå¤±è´¥', 'error');
                this.hideFullscreenOverlay();
            }
        } catch (error) {
            console.error('Create game error:', error);
            this.addMessage('åˆ›å»ºæ¸¸æˆæ—¶å‘ç”Ÿé”™è¯¯', 'error');
            this.hideFullscreenOverlay();
        } finally {
            this.setLoading(false);
        }
    }

    handleGameOver(reason) {
        // æ˜¾ç¤ºæ¸¸æˆç»“æŸç•Œé¢
        this.addMessage(`æ¸¸æˆç»“æŸï¼š${reason}`, 'error');

        // ç¦ç”¨æ‰€æœ‰æ§åˆ¶æŒ‰é’®
        const controlButtons = document.querySelectorAll('.control-btn, .dir-btn');
        controlButtons.forEach(btn => {
            btn.disabled = true;
        });

        // æ˜¾ç¤ºæ¸¸æˆç»“æŸæ¨¡æ€æ¡†
        setTimeout(() => {
            const gameOverModal = this.createGameOverModal(reason);
            document.body.appendChild(gameOverModal);
        }, 1000);
    }

    createGameOverModal(reason) {
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.style.display = 'block';
        modal.innerHTML = `
            <div class="modal-content" style="text-align: center; max-width: 400px;">
                <h2 style="color: #e74c3c; margin-bottom: 20px;">
                    <i class="material-icons" style="font-size: 48px; display: block; margin-bottom: 10px;">sentiment_very_dissatisfied</i>
                    æ¸¸æˆç»“æŸ
                </h2>
                <p style="font-size: 18px; margin-bottom: 20px;">${reason}</p>
                <div style="margin-bottom: 20px;">
                    <p>ä½ çš„å†’é™©åˆ°æ­¤ç»“æŸ...</p>
                    <p>ä½†æ˜¯ä¸è¦æ”¾å¼ƒï¼Œæ–°çš„å†’é™©ç­‰å¾…ç€ä½ ï¼</p>
                </div>
                <div style="display: flex; gap: 10px; justify-content: center;">
                    <button class="btn btn-primary" onclick="location.reload()">
                        <i class="material-icons">refresh</i>
                        é‡æ–°å¼€å§‹
                    </button>
                    <button class="btn btn-secondary" onclick="this.closest('.modal').remove(); document.getElementById('main-menu').style.display = 'block'; document.getElementById('game-interface').style.display = 'none';">
                        <i class="material-icons">home</i>
                        è¿”å›ä¸»èœå•
                    </button>
                </div>
            </div>
        `;
        return modal;
    }

    // æ–°å¢ï¼šéƒ¨åˆ†é®ç½©æ–¹æ³•ï¼ˆåªé®ä½åœ°å›¾åŒºåŸŸï¼‰
    showPartialOverlay(title, subtitle, description) {
        let overlay = document.getElementById('partial-overlay');
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.id = 'partial-overlay';
            overlay.className = 'partial-overlay';
            overlay.innerHTML = `
                <div class="partial-overlay-content">
                    <div class="overlay-header">
                        <h3 id="partial-overlay-title">${title}</h3>
                        <p id="partial-overlay-subtitle">${subtitle}</p>
                    </div>
                    <div class="overlay-body">
                        <div class="progress-container">
                            <div class="progress-bar">
                                <div class="progress-fill" id="partial-progress-fill"></div>
                            </div>
                            <p class="progress-text" id="partial-progress-text">${description}</p>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);
        } else {
            document.getElementById('partial-overlay-title').textContent = title;
            document.getElementById('partial-overlay-subtitle').textContent = subtitle;
            document.getElementById('partial-progress-text').textContent = description;
            document.getElementById('partial-progress-fill').style.width = '0%';
        }

        overlay.style.display = 'flex';
    }

    hidePartialOverlay() {
        const overlay = document.getElementById('partial-overlay');
        if (overlay) {
            overlay.style.display = 'none';
        }
    }

    updateOverlayProgress(percentage, text = null) {
        // æ›´æ–°å…¨å±é®ç½©è¿›åº¦
        const fullProgressFill = document.getElementById('progress-fill');
        const fullProgressText = document.getElementById('progress-text');

        if (fullProgressFill) {
            fullProgressFill.style.width = `${percentage}%`;
        }
        if (fullProgressText && text) {
            fullProgressText.textContent = text;
        }

        // æ›´æ–°éƒ¨åˆ†é®ç½©è¿›åº¦
        const partialProgressFill = document.getElementById('partial-progress-fill');
        const partialProgressText = document.getElementById('partial-progress-text');

        if (partialProgressFill) {
            partialProgressFill.style.width = `${percentage}%`;
        }
        if (partialProgressText && text) {
            partialProgressText.textContent = text;
        }
    }

    // æ–°å¢ï¼šåœ°å›¾åˆ‡æ¢æ–¹æ³•
    async transitionMap(transitionType) {
        if (this.isLoading || !this.gameId) return;

        this.setLoading(true);
        this.showPartialOverlay('åœ°å›¾åˆ‡æ¢', 'æ­£åœ¨è¿›å…¥æ–°åŒºåŸŸ...', 'å‡†å¤‡ç»§ç»­ä½ çš„å†’é™©...');

        try {
            const response = await fetch(`/api/game/${this.gameId}/transition`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    type: transitionType
                })
            });

            const result = await response.json();

            if (result.success) {
                this.updateOverlayProgress(70, 'åŠ è½½æ–°åœ°å›¾...');

                // æ›´æ–°æ¸¸æˆçŠ¶æ€
                this.gameState = result.game_state;

                this.updateOverlayProgress(90, 'æ›´æ–°ç•Œé¢...');

                // é‡æ–°æ¸²æŸ“æ¸¸æˆç•Œé¢
                this.renderGame();

                // æ˜¾ç¤ºäº‹ä»¶æ¶ˆæ¯
                if (result.events) {
                    result.events.forEach(event => {
                        this.addMessage(event, 'event');
                    });
                }

                this.updateOverlayProgress(100, 'å®Œæˆï¼');

                setTimeout(() => {
                    this.hidePartialOverlay();
                }, 500);
            } else {
                this.addMessage(result.message || 'åœ°å›¾åˆ‡æ¢å¤±è´¥', 'error');
                this.hidePartialOverlay();
            }
        } catch (error) {
            console.error('Map transition error:', error);
            this.addMessage('åœ°å›¾åˆ‡æ¢æ—¶å‘ç”Ÿé”™è¯¯', 'error');
            this.hidePartialOverlay();
        } finally {
            this.setLoading(false);
        }
    }

    // æ›´æ–°æ§åˆ¶é¢æ¿ä»¥æ˜¾ç¤ºåœ°å›¾åˆ‡æ¢æŒ‰é’®
    updateControlPanel() {
        const controlPanel = document.querySelector('.controls');
        if (!controlPanel) {
            console.warn('Control panel not found');
            return;
        }

        // æ£€æŸ¥æ˜¯å¦æœ‰å¾…åˆ‡æ¢çš„åœ°å›¾
        const hasPendingTransition = this.gameState && this.gameState.pending_map_transition;

        // è°ƒè¯•ä¿¡æ¯
        if (this.config && this.config.debug_mode) {
            console.log('updateControlPanel called');
            console.log('gameState:', this.gameState);
            console.log('pending_map_transition:', this.gameState?.pending_map_transition);
            console.log('hasPendingTransition:', hasPendingTransition);
        }

        let transitionButton = document.getElementById('transition-button');

        if (hasPendingTransition) {
            if (!transitionButton) {
                transitionButton = document.createElement('button');
                transitionButton.id = 'transition-button';
                transitionButton.className = 'btn btn-warning control-btn transition-btn';
                controlPanel.appendChild(transitionButton);

                if (this.config && this.config.debug_mode) {
                    console.log('Transition button created and added to DOM');
                    console.log('Control panel:', controlPanel);
                    console.log('Button element:', transitionButton);
                }
            }

            const transitionType = this.gameState.pending_map_transition;
            const buttonText = transitionType === 'stairs_down' ? 'è¿›å…¥ä¸‹ä¸€å±‚' : 'è¿”å›ä¸Šä¸€å±‚';
            const iconName = transitionType === 'stairs_down' ? 'keyboard_arrow_down' : 'keyboard_arrow_up';

            transitionButton.innerHTML = `
                <i class="material-icons">${iconName}</i>
                ${buttonText}
            `;

            transitionButton.onclick = () => this.transitionMap(transitionType);
            transitionButton.disabled = this.isLoading;

            if (this.config && this.config.debug_mode) {
                console.log('Transition button created/updated:', buttonText);
            }
        } else if (transitionButton) {
            transitionButton.remove();
            if (this.config && this.config.debug_mode) {
                console.log('Transition button removed');
            }
        }

        // è°ƒè¯•æ¨¡å¼ä¸‹æ·»åŠ æµ‹è¯•æŒ‰é’®
        if (this.config && this.config.debug_mode && this.gameId) {
            let testButton = document.getElementById('test-transition-button');
            if (!testButton) {
                testButton = document.createElement('button');
                testButton.id = 'test-transition-button';
                testButton.className = 'btn btn-info control-btn';
                testButton.innerHTML = '<i class="material-icons">bug_report</i>æµ‹è¯•æ¥¼æ¢¯';
                testButton.onclick = () => {
                    // æ‰‹åŠ¨è®¾ç½®å¾…åˆ‡æ¢çŠ¶æ€è¿›è¡Œæµ‹è¯•
                    if (this.gameState) {
                        this.gameState.pending_map_transition = 'stairs_down';
                        this.updateControlPanel();
                    }
                };
                controlPanel.appendChild(testButton);
            }
        }
    }
}

// åˆå§‹åŒ–æ¸¸æˆ
const game = new LabyrinthiaGame();
